---

---

# 클래스(Class)

## 1. 객체 지향 프로그래밍

하나하나 조립해서 완성된 프로그램을 만드는 기법을 객체 지향 프로그래밍 (OOP:Object Oriented Programing) 이다.

### 객체란?

물리적으로 존재하는 자동차, 자전거, 책, 사람과 추상적인 학과, 강의, 주문 등이 모두 객체가 될 수 있다. 객체는 **속성**과 **동작** 으로 구성되어 있다. 예를 들어 사람은 이름, 나이 등의 **속성**과 웃다, 걷다 등의 **동작**이 있고, 자동차는 색상, 모델명등의 **속성**과 달린다, 멈춘다 등의 **동작**이 있다. 자바는 이 속성과 동작을 각각 필드(field)와 메소드(method)라고 부른다.

![Object](C:\Users\supre\Desktop\Github\img\Class\Object.png)

### 객체의 상호작용

사람은 전자계산기의 기능을 이용하고, 전자계산기는 계산 결과를 사람에게 알려주는 상호작용을 한다. 객체들도 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용 하면서 동작한다. 객체들 사이의 상호작용 수단은 메소드이고, 객체가 다른 객체의 기능을 이용하는 것이 바로 메소드 호출이다.

![Object2](C:\Users\supre\Desktop\Github\img\Class\Object2.png)

객체에 도트( . ) 연산자를 붙이고 메소드 이름을 기술하면 된다.

```java
리턴값 = 전자계산기객체.메소드(매개값1, 매개값2, ···);
```

매개값은 메소드를 실행하기 위한 필요한 데이터이다. 예를 들어 10과 20을 주고 더하기 기능을 이용한다라고 했을 때 10과 20이 더하기 기능의 매개값이다. 리턴값은 메소드가 실행하고 나서 호출 한 곳으로 돌려주는 값이다.

![Object3](C:\Users\supre\Desktop\Github\img\Class\Object3.png)

```java
int result = Calculator.add(10, 20);
//리턴한 값을 int 변수에 저장
```

객체의 상호작용은 객체 간의 메소드 호출을 의미하며 매개값과 리턴값을 통해서 데이터를 주고 받는다.



### 객체 간의 관계

객체는 대부분 다른 객체와 관계를 맺고 있다. 이 관계의 종류에는 집합 관계, 사용 관계, 상속 관계가 있다. 

- 집합관계 : 객체 하나가 부품이고 하나는 완성품에 해당
  - Ex) 자동차는 엔진, 타이어, 핸들 등으로 구성되므로 자동차와 부품들은 집합관계이다.
- 사용관계 : 객체 간의 상호작용, 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어 낸다. 
  -  Ex) 사람은 자동차를 사용하므로 사람과 자동차는 사용의 관계이다.
- 상속관계 : 상위(부모)객체를 기반으로 하위(자식) 객체를 생성하는 관계이다.
  -  Ex) 자동차는 기계의 종류 이다는 기계(상위)와 자동차(하위)는 상속관계이다.

객체 지향 프로그래밍(OOP : Object Oriented Programing)은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 개발하는 기법이다.

![Object4](C:\Users\supre\Desktop\Github\img\Class\Object4.png)

### 객체 지향 프로그래밍의 특징

캡슐화, 상속, 다형성의 특징을 갖고 있다.

#### 캡슐화(Encapsulation)

객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.

![Object5](C:\Users\supre\Desktop\Github\img\Class\Object5.png)

필드와 메소드를 캡슐화하여 보하하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않게 하는데 있다. TV의 중요 부품이 밖으로 노출되어 있다면, 사용자의 실수로 인해 고장날 수도 있다. 자바 언어는 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다. 



#### 상속(Inheritance)

일반적인 상속은 부모가 가지고 있는 재산을 자식에게 물려주는 것을 말한다. 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려 주어 하위 객체가 사용할 수 있도록 해준다.

![Object6](C:\Users\supre\Desktop\Github\img\Class\Object6.png)

상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄인다.

예들 들어 필드1, 필드2, 메소드1, 메소드2를 가지는 객체를 설계한다고 했을 때, 4개를 모두 처음부터 설계하는 것보다는 이미 필드1과 메소드1이 있는 객체가 있다면, 이것을 상속하고, 필드2와 메소드2만 설계하는 것이 보다 효율적이고 개발 시간을 절약해 준다.



상속은 상위 개체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로 유지 보수 시간을 최소화시켜주기도 한다.

예를 들어 객체 B, C가 객체 A를 상속할 경우 A의 필드와 메소드를 수정함으로써 객체 B, C를 수정하지 않아도 객체 A의 수정된 필드와 메소드를 사용 할 수 있다.



#### 다형성(Polymorphism)

같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다. 다형성의 효과로는 객체의 부품화가 가능하다.

예를 들어 자동차를 설계할 때 타이어 틴터페이스 타입을 적용했다면 이 인터페이스를 구현한 실제 타이어들은 어떤 것이든 상관없이 장착(대입)이 가능하다.



### 객체와 클래스

자동차를 제작하기 위해서 설계도를 보고 자동차를 만들어야 한다. 객체 지향 프로그래밍도 우선 설계도로 해당하는 객체를 만드는 작업이 필요하다. 그 설계도는 클래스(class)이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다. 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다. 그리고 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다. 하나의 클래스로 부터 여러 개의 인스턴스를 만들 수 있는데, 이것은 동일한 설계도로부터 여러 대의 자동차를 만드는 것과 동일하다.

객체 지향 프로그래밍 개발은 세 가지 단계가 있다. 첫 번째 단계는 클래스를 설계, 두 번째 단계는 설계된 클래스를 가지고 사용할 객체를 생성해야 한다. 마지막 단계는 생성된 객체를 이용하는 것이다.



### 클래스 선언

사람의 객체의 클래스는 Person으로, 자동차 객체의 클래스는 Car라는 이름으로 줄 수 있다. 자바의 식별자 작성 규칙에 따라서 만들어야 한다.

| 번호 | 작성 규치                                | 예               |
| ---- | ---------------------------------------- | ---------------- |
| 1    | 하나 이상의 문자로 이루어져야 한다.      | Car, SportsCar   |
| 2    | 첫 번째 글자는 숫자가 올 수 없다.        | 3Car(x)          |
| 3    | '$', '_'외의 특수 문자는 사용할 수 없다. | @Car(x), #Car(x) |
| 4    | 자바 키워드는 사용할 수 없다.            | int(x), for(x)   |

일반적으로 소스 파일당 하나의 클래스를 선언한다. 하지만, 두 개 이상의 클래스 선언도 가능하다.

```java
public class Car{

}

class Tire{

}
```

두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생긴다. 결국 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다. 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다. 



### 객체 생성과 클래스 변수

클래스로부터 객체를 생성하는 방법은 다음과 같이 new연산자를 사용하면 된다.

```java
new 클래스();
```

![ObjectClass](C:\Users\supre\Desktop\Github\img\Class\ObjectClass.png)

new는 클래스로부터 객체를 생성시키는 연산자 이다. new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다. 현실 세계에서 물건의 위치를 모르면 물건을 사용할 수 없듯이, 객체 지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다. 따라서 new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다.

```java
클래스 변수;
변수 = new 클래스();
클래스 변수 = new 클래스():
```

이렇게 new 연산자로 객체를 생성하고 리턴된 객체의 주소를 변수에 저장하면 다음 그림과 같이 변수가 객체를 참조하게 된다.

![ObjectClass2](C:\Users\supre\Desktop\Github\img\Class\ObjectClass2.png)

Student클래스를 선언하고 StudentExample 클래스의 main() 메소드에서 Student 객체를 생성한다.

#### 예제 Student.java(클래스 선언)

```java
public class Student{
}
```

#### 예제 StudentExample.java(클래스로부터 객체 생성)

```java
public class StudentExample {
    public static void main(String[] args) {
        Student s1 = new Student();
        System.out.println("s1 변수가 Student 객체를 참조합니다.");
        
        Student s2 = new Student();
        System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다.");
    }
}
```

#### 결과

```java
s1 변수가 Student 객체를 참조합니다.
s2 변수가 또 다른 Student 객체를 참조합니다.
```

예제가 실행되면 다음 그림과 같이 메모리에 클래스 변수와 객체가 생성된다. Student 클래스는 하나지만 new 연산자를 사용한 만큼 객체가 메모리에 생성된다. 이러한 객체들은 Student 클래스의 인스턴스들이다. s1과 s2가 참조하는 Student 객체는 완전히 독립된 서로 다른 객체이다.

 ![ObjectClass3](C:\Users\supre\Desktop\Github\img\Class\ObjectClass3.png)

여기서 Student와 StudentExample 클래스의 용도에 대해 알아볼 필요가 있다. 클래스는 두 가지 용도가 있다. 하나는 라이브러리(API : Aplication Program Interface)용이고 다른 하나는 실행용이다. 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리이고 단 하나가 실행 클래스이다. Student는 라이브러리 클래스이고 StudentExample은 실행 클래스이다. Student에 main() 메소드를 작성해서 라이브러리인 동시에 실행 클래스로 만들 수도 있다.

```java
public class Student {
    //라이브러리로서의 코드(필드, 생성자, 메소드)
    //...
    //실행하기 위한 코드
    public static void main(String[] args) {
        Student s1 = new Student();
        System.out.println("s1 변수가 Student 객체를 참조합니다.");
        
        Student s2 = new Student();
        System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다.");
    }
}
```



### 클래스의 구성 멤버

클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 구성 멤버에는 필드(Field), 생성자(Constructor), 메소드(Method)가 있다.

![ClassMember](C:\Users\supre\Desktop\Github\img\Class\ClassMember.png)

#### 필드

필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳. 선언 형태는 변수(variable)와 비슷하지만, 필드를 변수라고 부르지 않는다. 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다. 



#### 생성자

생성자는 new 연산자로 호출되는 특별한 중괄화 { } 블록이다. 생성자의 역할은 객체 생성 시 초기화를 담당한다. 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다. 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없다. 



#### 메소드

메소드는 객체의 동작에 해당하는 중괄호 { } 블록을 말한다. 중괄호 블록은 이름을 가지고 있는데, 이것이 메소드 이름이다. 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다. 메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 메소드는 객체간의 데이터 전달의 수단으로 사용되고, 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있다.