# 클래스(Class)

## 1. 객체 지향 프로그래밍

하나하나 조립해서 완성된 프로그램을 만드는 기법을 객체 지향 프로그래밍 (OOP:Object Oriented Programing) 이다.

### 객체란?

물리적으로 존재하는 자동차, 자전거, 책, 사람과 추상적인 학과, 강의, 주문 등이 모두 객체가 될 수 있다. 객체는 **속성**과 **동작** 으로 구성되어 있다. 예를 들어 사람은 이름, 나이 등의 **속성**과 웃다, 걷다 등의 **동작**이 있고, 자동차는 색상, 모델명등의 **속성**과 달린다, 멈춘다 등의 **동작**이 있다. 자바는 이 속성과 동작을 각각 필드(field)와 메소드(method)라고 부른다.

![Object](C:\Users\supre\Desktop\Github\img\Class\Object.png)

### 객체의 상호작용

사람은 전자계산기의 기능을 이용하고, 전자계산기는 계산 결과를 사람에게 알려주는 상호작용을 한다. 객체들도 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용 하면서 동작한다. 객체들 사이의 상호작용 수단은 메소드이고, 객체가 다른 객체의 기능을 이용하는 것이 바로 메소드 호출이다.

![Object2](C:\Users\supre\Desktop\Github\img\Class\Object2.png)

객체에 도트( . ) 연산자를 붙이고 메소드 이름을 기술하면 된다.

```java
리턴값 = 전자계산기객체.메소드(매개값1, 매개값2, ···);
```

매개값은 메소드를 실행하기 위한 필요한 데이터이다. 예를 들어 10과 20을 주고 더하기 기능을 이용한다라고 했을 때 10과 20이 더하기 기능의 매개값이다. 리턴값은 메소드가 실행하고 나서 호출 한 곳으로 돌려주는 값이다.

![Object3](C:\Users\supre\Desktop\Github\img\Class\Object3.png)

```java
int result = Calculator.add(10, 20);
//리턴한 값을 int 변수에 저장
```

객체의 상호작용은 객체 간의 메소드 호출을 의미하며 매개값과 리턴값을 통해서 데이터를 주고 받는다.



### 객체 간의 관계

객체는 대부분 다른 객체와 관계를 맺고 있다. 이 관계의 종류에는 집합 관계, 사용 관계, 상속 관계가 있다. 

- 집합관계 : 객체 하나가 부품이고 하나는 완성품에 해당
  - Ex) 자동차는 엔진, 타이어, 핸들 등으로 구성되므로 자동차와 부품들은 집합관계이다.
- 사용관계 : 객체 간의 상호작용, 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어 낸다. 
  -  Ex) 사람은 자동차를 사용하므로 사람과 자동차는 사용의 관계이다.
- 상속관계 : 상위(부모)객체를 기반으로 하위(자식) 객체를 생성하는 관계이다.
  -  Ex) 자동차는 기계의 종류 이다는 기계(상위)와 자동차(하위)는 상속관계이다.

객체 지향 프로그래밍(OOP : Object Oriented Programing)은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 개발하는 기법이다.

![Object4](C:\Users\supre\Desktop\Github\img\Class\Object4.png)

### 객체 지향 프로그래밍의 특징

캡슐화, 상속, 다형성의 특징을 갖고 있다.

#### 캡슐화(Encapsulation)

객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.

![Object5](C:\Users\supre\Desktop\Github\img\Class\Object5.png)

필드와 메소드를 캡슐화하여 보하하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않게 하는데 있다. TV의 중요 부품이 밖으로 노출되어 있다면, 사용자의 실수로 인해 고장날 수도 있다. 자바 언어는 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다. 



#### 상속(Inheritance)

일반적인 상속은 부모가 가지고 있는 재산을 자식에게 물려주는 것을 말한다. 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려 주어 하위 객체가 사용할 수 있도록 해준다.

![Object6](C:\Users\supre\Desktop\Github\img\Class\Object6.png)

상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄인다.

예들 들어 필드1, 필드2, 메소드1, 메소드2를 가지는 객체를 설계한다고 했을 때, 4개를 모두 처음부터 설계하는 것보다는 이미 필드1과 메소드1이 있는 객체가 있다면, 이것을 상속하고, 필드2와 메소드2만 설계하는 것이 보다 효율적이고 개발 시간을 절약해 준다.



상속은 상위 개체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로 유지 보수 시간을 최소화시켜주기도 한다.

예를 들어 객체 B, C가 객체 A를 상속할 경우 A의 필드와 메소드를 수정함으로써 객체 B, C를 수정하지 않아도 객체 A의 수정된 필드와 메소드를 사용 할 수 있다.



#### 다형성(Polymorphism)

같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다. 다형성의 효과로는 객체의 부품화가 가능하다.

예를 들어 자동차를 설계할 때 타이어 틴터페이스 타입을 적용했다면 이 인터페이스를 구현한 실제 타이어들은 어떤 것이든 상관없이 장착(대입)이 가능하다.



### 객체와 클래스

자동차를 제작하기 위해서 설계도를 보고 자동차를 만들어야 한다. 객체 지향 프로그래밍도 우선 설계도로 해당하는 객체를 만드는 작업이 필요하다. 그 설계도는 클래스(class)이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다. 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다. 그리고 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다. 하나의 클래스로 부터 여러 개의 인스턴스를 만들 수 있는데, 이것은 동일한 설계도로부터 여러 대의 자동차를 만드는 것과 동일하다.

객체 지향 프로그래밍 개발은 세 가지 단계가 있다. 첫 번째 단계는 클래스를 설계, 두 번째 단계는 설계된 클래스를 가지고 사용할 객체를 생성해야 한다. 마지막 단계는 생성된 객체를 이용하는 것이다.



### 클래스 선언

사람의 객체의 클래스는 Person으로, 자동차 객체의 클래스는 Car라는 이름으로 줄 수 있다. 자바의 식별자 작성 규칙에 따라서 만들어야 한다.

| 번호 | 작성 규치                                | 예               |
| ---- | ---------------------------------------- | ---------------- |
| 1    | 하나 이상의 문자로 이루어져야 한다.      | Car, SportsCar   |
| 2    | 첫 번째 글자는 숫자가 올 수 없다.        | 3Car(x)          |
| 3    | '$', '_'외의 특수 문자는 사용할 수 없다. | @Car(x), #Car(x) |
| 4    | 자바 키워드는 사용할 수 없다.            | int(x), for(x)   |

일반적으로 소스 파일당 하나의 클래스를 선언한다. 하지만, 두 개 이상의 클래스 선언도 가능하다.

```java
public class Car{

}

class Tire{

}
```

두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생긴다. 결국 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다. 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다. 



### 객체 생성과 클래스 변수

클래스로부터 객체를 생성하는 방법은 다음과 같이 new연산자를 사용하면 된다.

```java
new 클래스();
```

![ObjectClass](C:\Users\supre\Desktop\Github\img\Class\ObjectClass.png)

new는 클래스로부터 객체를 생성시키는 연산자 이다. new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다. 현실 세계에서 물건의 위치를 모르면 물건을 사용할 수 없듯이, 객체 지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다. 따라서 new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다.

```java
클래스 변수;
변수 = new 클래스();
클래스 변수 = new 클래스():
```

이렇게 new 연산자로 객체를 생성하고 리턴된 객체의 주소를 변수에 저장하면 다음 그림과 같이 변수가 객체를 참조하게 된다.

![ObjectClass2](C:\Users\supre\Desktop\Github\img\Class\ObjectClass2.png)

Student클래스를 선언하고 StudentExample 클래스의 main() 메소드에서 Student 객체를 생성한다.

#### 예제 Student.java(클래스 선언)

```java
public class Student{
}
```

#### 예제 StudentExample.java(클래스로부터 객체 생성)

```java
public class StudentExample {
    public static void main(String[] args) {
        Student s1 = new Student();
        System.out.println("s1 변수가 Student 객체를 참조합니다.");
        
        Student s2 = new Student();
        System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다.");
    }
}
```

#### 결과

```java
s1 변수가 Student 객체를 참조합니다.
s2 변수가 또 다른 Student 객체를 참조합니다.
```

예제가 실행되면 다음 그림과 같이 메모리에 클래스 변수와 객체가 생성된다. Student 클래스는 하나지만 new 연산자를 사용한 만큼 객체가 메모리에 생성된다. 이러한 객체들은 Student 클래스의 인스턴스들이다. s1과 s2가 참조하는 Student 객체는 완전히 독립된 서로 다른 객체이다.

 ![ObjectClass3](C:\Users\supre\Desktop\Github\img\Class\ObjectClass3.png)

여기서 Student와 StudentExample 클래스의 용도에 대해 알아볼 필요가 있다. 클래스는 두 가지 용도가 있다. 하나는 라이브러리(API : Aplication Program Interface)용이고 다른 하나는 실행용이다. 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리이고 단 하나가 실행 클래스이다. Student는 라이브러리 클래스이고 StudentExample은 실행 클래스이다. Student에 main() 메소드를 작성해서 라이브러리인 동시에 실행 클래스로 만들 수도 있다.

```java
public class Student {
    //라이브러리로서의 코드(필드, 생성자, 메소드)
    //...
    //실행하기 위한 코드
    public static void main(String[] args) {
        Student s1 = new Student();
        System.out.println("s1 변수가 Student 객체를 참조합니다.");
        
        Student s2 = new Student();
        System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다.");
    }
}
```



### 클래스의 구성 멤버

클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 구성 멤버에는 필드(Field), 생성자(Constructor), 메소드(Method)가 있다.

![ClassMember](C:\Users\supre\Desktop\Github\img\Class\ClassMember.png)

#### 필드

필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳. 선언 형태는 변수(variable)와 비슷하지만, 필드를 변수라고 부르지 않는다. 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다. 



#### 생성자

생성자는 new 연산자로 호출되는 특별한 중괄화 { } 블록이다. 생성자의 역할은 객체 생성 시 초기화를 담당한다. 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다. 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없다. 



#### 메소드

메소드는 객체의 동작에 해당하는 중괄호 { } 블록을 말한다. 중괄호 블록은 이름을 가지고 있는데, 이것이 메소드 이름이다. 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다. 메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 메소드는 객체간의 데이터 전달의 수단으로 사용되고, 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있다.



### 필드

필드(Field)는 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳이다. 자동차 객체를 예를 들어 보면 제작회사, 모델, 색깔, 최고 속도는 고유 데이터에 해당하고, 현재 속도, 엔진 회전 수는 상태 데이터에 해당한다.

![Class_Filed](C:\Users\supre\Desktop\Github\img\Class\Class_Filed.png)

#### 필드 선언

필드 선언은 변수의 선언 형태와 비슷하다. 가능하다면 클래스 멤버 변수보다 필드라는 용어를 사용하자.

```java
타입 필드 = 초기값;
```

초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 처기값으로 설정된다. 필드의 타입에 따라 초기값이 다른데, 다음 표는 필드 타입별 기본 초기값을 보여준다.

| 분류     |          | 데이터 타입        | 초기값          |
| -------- | -------- | ------------------ | --------------- |
| 기본타입 | 정수타입 | byte               | 0               |
|          |          | char               | /u0000(빈 공백) |
|          |          | short              | 0               |
|          |          | int                | 0               |
|          |          | long               | 0L              |
|          | 실수타입 | float              | 0.0F            |
|          |          | double             | 0.0             |
|          | 논리타입 | boolean            | false           |
| 참조타입 |          | 배열               | null            |
|          |          | 클래스(String)표현 | null            |
|          |          | 인터페이스         | null            |



#### 필드 사용

필드를 사용하는 것은 필드값을 읽고, 변경하는 작업을 말한다. 

![Class_Filed2](C:\Users\supre\Desktop\Github\img\Class\Class_Filed2.png)

위 그림을 보면 Car 클래스의 speed 필드는 생성자와 메소에서 변경이 가능하다. 사용 방법은 변수와 동일한데, 차이점은 변수는 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용할 수 있는 반면 필드는 생성자와 모든 메소드에서 사용이 가능하다. 외부 Person 클래스에서 Car 클래스의 speed 필드값을 사용하려면 Car 객체를 우선 생성해야 한다.

```java
Car myCar = new Car( );
```

 myCar 변수가 Car 객체를 참조하게 되면 도트( . ) 연산자를 사용해서 speed 필드에 접근할 수 있다. 도트 ( . ) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나, 메소드를 사용하고자 할 때 사용된다. 



#### 예제 Car.java( Car 클래스 필드 선언 )

```java
public class Car {
    //필드
    String company = "현대자동차";
    String model = "그렌저";
    String color = "검정";
    int maxSpeed = 350;
    int speed;
}
```



#### 예제 CarExample.java( 외부 클래스에서  Car 필드값 읽기와 변경 )

```java
public class CarExample {
    public static void main(String[] args) {
        //객체 생성
        Car myCar = new Car();
        
        //필드값 읽기
        System.out.println("제작회사 : " + myCar.company);
        System.out.println("모델명 : " + myCar.model);
        System.out.println("색상 : " + myCar.color);
        System.out.println("최고속도 : " + myCar.maxSpeed);
        System.out.println("현재속도 : " + myCar.speed);

        //필드값 변경
        myCar.speed = 60;
        System.out.println("수정된 속도 : " + myCar.speed);
    }
}
```



#### 결과

```java
제작회사 : 현대자동차
모델명 : 그렌저
색상 : 검정
최고속도 : 350
현재속도 : 0
수정된 속도 : 60
```



Car 클래스는 speed 필드 선언 시 초기값을 주지 않았다. 그러나 출력해보면 기본값이 0이 들어있다가 60으로 바뀐것을 알 수 있다.

다음 예제는 여러 가지 타입의 필드가 어떤 값으로 자동 초기화되는지 확인시켜 준다.

#### 예제 FieldInitValue.java( 필드 자동 초기화 )

```java
public class FiledInitVlaue {
    //필드
    byte byteField;
    short shortFiled;
    int intFiled;
    long longField;

    boolean booleanFiled;
    char charFiled;

    float floatFiled;
    double doubleFiled;

    int[] arrFiled;
    String stringFiled;
}
```



#### 예제 FiledInitValueExample.java( 필드값 출력 )

```java
public class FiledInitValueExample {
    public static void main(String[] args) {
        FiledInitVlaue fiv = new FiledInitVlaue();
        
        System.out.println("byteFiled : " + fiv.byteField);
        System.out.println("shortFiled : " + fiv.shortFiled);
        System.out.println("intFiled : " + fiv.intFiled);
        System.out.println("longFiled : " + fiv.longField);
        System.out.println("booleanFiled : " + fiv.booleanFiled);
        System.out.println("charFiled : " + fiv.charFiled);
        System.out.println("floatFiled : " + fiv.floatFiled);
        System.out.println("doubleFiled : " + fiv.doubleFiled);
        System.out.println("arrFiled : " + fiv.arrFiled);
        System.out.println("referenceFiled : " + fiv.referenceFiled);
    }
}
```



#### 결과

```java
byteFiled : 0
shortFiled : 0
intFiled : 0
longFiled : 0
booleanFiled : false
charFiled :
floatFiled : 0.0
doubleFiled : 0.0
arrFiled : null
referenceFiled : null
```



### 생성자

생성자(Constructor)는 new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다. 객체 초기화란 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것을 말한다. 생성자는 실행시키지 않고는 클래스로부터 객체를 만들 수 없다. new 연산자에 의해 생성자가 성공적으로 실행되면 힙(heap) 영역에 객체가 생성되고 객체의 주소가 리턴 된다. 리턴된객체의 주소는 클래스 타입 변수에 저장되어 객체에 접근할 때 이용된다.



#### 기본 생성자

모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 우리가 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 다음과 같이 중괄호 {} 블록 내용이 비어있는 기본 생성자(Default Constructor)를 바이트 코드에 자동 추가시킨다.

```java
[public] 클래스( ) { }
```

클래스가 public class로 선언되면 기본 생성자에서도 public이 붙지만, 클래스가 public 없이 class로만 선언되면 기본 생성자도 public이 붙지 않는다. 예를 들어 Car클래스를 설계할 때 생성자를 생략하면 기본 생성자가 다음과 같이 생성된다.

```java
소스 파일(Car.java)				바이트 코드 파일(Car.class)
------------------			  --------------------------
public class Car{		->	  public  class Car{
								pulblic Car( ) { } //자동추가
}							  }			기본 생성자
```

그렇기 때문에 클래스에 생성자를 선언하지 않아도 다음과 같이 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성시킬 수 있다.

```java
Car myCar = new Car( );
```

그러나 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가하지 않는다. 명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서이다. 그럼 생성자를 명시적으로 선언하는 방법에 대해 알아보자.



#### 생성자 선언

기본 생성자 대신 우리가 생성자를 명시적으로 선언하려면 다음과 같은 형태로 작성하면 된다.

```java
클래스( 매개변수선언, ㆍㆍㆍ ) {
	//객체의 초기화 코드			//생성자 블록
}
```

생성자는 리턴 타입이 없고 클래스 이름과 동일하다. 매개 변수 선언은 생략할 수도 있고, 여러 개를 선언해도 된다. 매개 변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.

```java
Car myCar = new Car("그렌저", "검정", 300);
```

세 매개값을 생성자가 받기 위해서는 다음과 같이 생성자를 선언한다.

```java
public class Car {
	//생성자
	Car(String model, String color, int maxSpeed) { ㆍㆍㆍ }
}
```

클래스에 생성자가 명시적으로 선언되어 있을 경우에는 반드시 선언된 생성자를 호출해서 객체를 생성해야만 한다. 

#### 예제 Car.java ( 생성자 선언 )

```java
public class Car {
    Car(String color, int cc){
    }
}
```



#### 예제 CarExample.java ( 생성자를 호출해서 객체 생성 )

```java
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car("검정",300);
        //Car myCar = new Car();    //기본 생성자를 호출할 수 없다.
    }
}
```



#### 필드 초기화

클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다. 만약 다른 값으로 초기화를 하고 싶다면, 하나는 필드를 선언할 때 초기값을 주는 방법, 다른 하나는 생성자에서 초기값을 주는 방법이다. 예를들어 Korean 클래스에 nation 필드를 선언하면서 "대한민국"으로 초기값을 준 경우, Korean 클래스로부터 k1과 k2 객체를 생성하면 k1과 k2 객체의 nation 필드에는 모두 "대한민국"이 저장되어 있다.

```java
public class Korean{						Korean k1 = new Korean();
	String nation = "대한민국";			     Korean k2 = new Korean();
	String name;
	String ssn;
}
```

객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면 생성자에서 초기화를 해야 한다. 위 코드에서 name(이름)과 ssn(주민번호) 필드값은 클래스를 작성할 때 초기값을 줄 수 없고 객체 생성 시점에 다양한 값을 가져야 한다.

```java
public class Korean {
	//필드
	String nation = "대한민국";
	String name;
	String ssn;
	
	//생성자
	public Korean(String n, String s){
		name = n;
		ssn = s;
	}
}
```

```java
Korean k1 = new Korean("박자바", "011225-1234567");
Korean k2 = new Korean("김자바", "910202-7654321");
```



#### 예제 Korean.java ( 생성자에서 필드 초기화 )

```java
public class Korean {
    //필드
    String nation = "대한민국";
    String name;
    String ssn;

    //생성자
    public Korean(String n, String s){
        name = n;
        ssn = s;
    }
}
```



#### 예제 KoreanExample.java ( 객체 생성 후 필드값 출력 )

```java
public class KoreanExample {
    public static void main(String[] args) {
        Korean k1 = new Korean("박자바", "011225-1234567");
        System.out.println("k1.name : " + k1.name);
        System.out.println("k1.ssn : " + k1.ssn);
                
        Korean k2 = new Korean("김자바", "910202-7654321");
        System.out.println("k2.name : " + k2.name);
        System.out.println("k2.ssn : " + k2.ssn);
        
    }
}
```



#### 결과

```java
k1.name : 박자바
k1.ssn : 011225-1234567
k2.name : 김자바
k2.ssn : 910202-7654321
```

Korean 생성자의 매개 변수 이름은 각각 n, s로 사용했으나, 코드의 가독성을 좋게 하기 위해 초기화시킬 필드 이름과 비슷하거나 동일한 이름을 사용할 것을 권한다. 관례적으로 필드와 동일한 이름을 갖는 매개 변수를 사용한다. 이 경우 필드와 매개변수 이름이 동일하기 때문에 생성자 내부에서 해당 필드에 접근할 수 없다. 왜냐하면 동일한 이름의 맥개 변수가 사용 우선순위가 높기 때문이다. 해결 방법은 필드 앞에 "
this."를 붙이면 된다. this는 객체 자신의 참조인데, 우리가 우리 자신을 "나"라고 하듯이 객체가 객체 자신을 this라고 한다. "this.필드"는 this라는 참조 변수로 필드를 사용하는 것과 동일하다. this를 이용하여 Korean생성자를 수정해보자.

```java
public Korean(String name, String ssn){
	this.name = name;
		 필드	  매개변수
 	this.ssn = ssn;
		 필드	 매개변수
}
```



#### 생성자 오버로딩(Overloading)

같은 이름의 생성자를 여러개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술로 매개 변수의 타입, 개수가 다르게 선언 되어야 한다.

```java
public class 클래스 {
	클래스 ( [타입 매개변수, ㆍㆍㆍ] ){
	
	}
	
	클래스 ( [타입 매개변수1, ㆍㆍㆍ] ){
	
	}
}
```



다음은 Car 클래스에서 생성자를 오버로딩한 예이다.

```java
public class Car {
	클래스( ){ ㆍㆍㆍ }
	클래스( String model ){ ㆍㆍㆍ }
	클래스( String model, String color ){ ㆍㆍㆍ }
	클래스( String model, String color, int maxSpeed ){ ㆍㆍㆍ }
}
```



#### 예제 Car.java ( 생성자의 오버로딩 )

```javascript
public class Car {
    //필드
    String company = "현대자동차";
    String model;
    String color;
    int maxSpeed;

    //생성자
    Car(){                                          //1번 생성자

    }
    Car(String model){                              //2번 생성자
        this.model = model;
    }
    Car(String model, String color){                //3번 생성자
        this.model = model;
        this.color = color;
    }
    Car(String model, String color, int maxSpeed){  //4번 생성자
        this.model = model;
        this.color = color;
        this.maxSpeed = maxSpeed;
    }
}
```



#### 예제 CarExample.java ( 객체 생성 시 생성자 선택 )

```java
public class CarExample {
    public static void main(String[] args) {
        Car Car1 = new Car();                                              //1번 생성자 선택
        System.out.println("Car1.company : " + Car1.company);
        System.out.println();

        Car Car2 = new Car("자가용");                                      //2번 생성자 선택
        System.out.println("Car2.company : " + Car2.company);
        System.out.println("Car2.model : " + Car2.model);
        System.out.println();

        Car Car3 = new Car("자가용", "빨강");                              //3번 생성자 선택
        System.out.println("Car3.company : " + Car3.company);
        System.out.println("Car3.model : " + Car3.model);
        System.out.println("Car3.color : " + Car3.color);
        System.out.println();

        Car Car4 = new Car("택시", "검정", 200);                           //4번 생성자 선택
        System.out.println("Car4.company : " + Car4.company);
        System.out.println("Car4.model : " + Car4.model);
        System.out.println("Car4.color : " + Car4.color);
        System.out.println("Car4.maxSpeed : " + Car4.maxSpeed);
    }
}
```



#### 결과

```java
Car1.company : 현대자동차

Car2.company : 현대자동차
Car2.model : 자가용

Car3.company : 현대자동차
Car3.model : 자가용
Car3.color : 빨강

Car4.company : 현대자동차
Car4.model : 택시
Car4.color : 검정
Car4.maxSpeed : 200
```



#### 다른 생성자 호출

생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다. 이 경우에는 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다. 다음과 같이 this( ) 코드를 사용한다.

```java
클래스( [매개변수선언, ㆍㆍㆍ] ) {
	this( 매개변수, ㆍㆍㆍ, 값, ㆍㆍㆍ);		//클래스의 다른 생성자 호출
	실행문;
}
```

this( )는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에만 허용된다. this( )의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 한다. this( ) 다음에는 추가적인 실행문이 올 수 있다. 다음 코드를 보면서 생성자 오버로딩에서 생기는 중복 코드를 제거해 보자.

```java
Car( String model ) {
	this.model = model;
	this.color = "은색";			//중복코드들
	this.maxSpeed = 250;
}

Car( String model, String color ) {
	this.model = model;
	this.color = "은색";			//중복코드들
	this.maxSpeed = 250;
}

Car( String model, String color, int maxSpeed ) {
	this.model = model;
	this.color = "은색";			//중복코드들
	this.maxSpeed = 250;
}
```

위에 코드를 보면 세 개의 생성자 내용이 비슷하므로 앞에 두 개의 생성자에서 this( )를 사용해서 마지막 생성자인 Car( String model, String color, int maxSpeed )를 호출하도록 수정하면 중복 코드를 최소화할 수 있다.



#### 예제 Car.java ( 다른 생성자를 호출해서 중복 코드 줄이기 )

```
public class Car {
    //필드
    String company = "현대자동차";
    String model;
    String color;
    int maxSpeed;

    //생성자
    Car(){
    }

    Car(String model){
        this(model, "은색", 250);
    }

    Car(String model, String color){
        this(model, color, 250);
    }

    Car(String model, String color, int maxSpeed){
        this.model = model;
        this.color = color;
        this.maxSpeed = maxSpeed;
    }
}
```

#### 예제 CarExample.java ( 객체 생성 시 생성자 선택 )

```java
public class CarExample {
    public static void main(String[] args) {
        Car Car1 = new Car();                                              //1번 생성자 선택
        System.out.println("Car1.company : " + Car1.company);
        System.out.println();

        Car Car2 = new Car("자가용");                                      //2번 생성자 선택
        System.out.println("Car2.company : " + Car2.company);
        System.out.println("Car2.model : " + Car2.model);
        System.out.println();

        Car Car3 = new Car("자가용", "빨강");                              //3번 생성자 선택
        System.out.println("Car3.company : " + Car3.company);
        System.out.println("Car3.model : " + Car3.model);
        System.out.println("Car3.color : " + Car3.color);
        System.out.println();

        Car Car4 = new Car("택시", "검정", 200);                           //4번 생성자 선택
        System.out.println("Car4.company : " + Car4.company);
        System.out.println("Car4.model : " + Car4.model);
        System.out.println("Car4.color : " + Car4.color);
        System.out.println("Car4.maxSpeed : " + Car4.maxSpeed);
    }
}
```



#### 결과

```java
Car1.company : 현대자동차

Car2.company : 현대자동차
Car2.model : 자가용

Car3.company : 현대자동차
Car3.model : 자가용
Car3.color : 빨강

Car4.company : 현대자동차
Car4.model : 택시
Car4.color : 검정
Car4.maxSpeed : 200
```



### 메소드

메소드는 객체의 동작에 해당하는 중괄호 { } 블록을 말한다. 중괄호 블록은 이름을 가지고 있는데, 이것이 메소드 이름이다. 메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.



#### 메소드 선언

메소드 선언은 선언부 ( 리턴타입, 메소드이름, 매개변수선언 )와 실행 블록으로 구성된다. 메소드 선언부를 메소드 시그너처(signature)라고도 한다.

![Method](C:\Users\supre\Desktop\Github\img\Class\Method.png)

##### 리턴 타입

리턴 타입은 메소드가 실행 후 리턴하는 값의 타입을 말한다. 메소드는 리턴값이 있을 수도 있고 없을 수 도 있다. 메소드가 실행 후 결과를 호출한 곳에 넘겨줄 경우에는 리턴값이 있어야 한다. 전자계산기 객체에서 전원을 켜는 powerOn( ) 메소드와 두 수를 나누는 기능인 divide( )메소드가 있다고 가정하고, divide( ) 메소드는 나눗셈의 결과를 리턴해야 하지만  powerOn( ) 메소드는 전원만 켜면 끝이다. 따라서 powerOn( ) 메소드는 리턴값이 없고, divide( ) 메소드는 리턴값이 있다고 봐야 한다.

```java
void powerOn( ) { ㆍㆍㆍ }
double divide( int x, int y ) { ㆍㆍㆍ }
```

리턴값이 있는냐 없느냐에 따라 메소드를 호출하는 방법이 조금 다르다.

```java
powerOn( );
double result = divide(10, 20);				//divide(10 ,20);
```



#### 메소드 이름

메소드 이름은 자바 식별자 규칙에 맞게 작성하면 되는데, 다음 사항에 주의하면 된다.

- 숫자로 시작하면 안되고, $와_를 제외한 특수 문자를 사용하지 말아야 한다.
- 관례적으로 메소드명은 **소문자**로 작성한다.
- 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫머리 글자는 **대문자**로 작성한다.

```java
void run( ) { ㆍㆍㆍ }
void startEngine( ) { ㆍㆍㆍ }
String getName( ) { ㆍㆍㆍ }
int[] getScores( ) { ㆍㆍㆍ }
```



#### 매개 변수 선언

매개 변수는 필요한 경우가 있고 필요 없는 경우가 있다. 앞서 설명했던 powerOn( )과 divide( ) 예시와 동일하다.



#### 예제 Calculator.java (  메소드 선언 )

```java
public class Calculator {
	//메소드
	void powerOn( ) {
        System.out.println("전원이 켜졌습니다.");
    }
    
    int plus( int x, int y) {
        int result = x + y;
        return result;
    }

    double divide ( int x, int y){
        double result = (double)x / (double)y;
        return result;
    }

    void powerOff( ) {
        System.out.println("전원이 꺼졌습니다.");
    }
}
```



#### 예제 CalculaotrExample.java ( 메소드 호출 )

```java
public class CalculatorExample {
    public static void main(String[] args) {
        Calculator myCalc = new Calculator();
        myCalc.powerOn();

        int result1 = myCalc.plus(5, 6);
        System.out.println("result1 : " + result1);

        byte x = 10;
        byte y = 4;
        double result2 = myCalc.divide(x, y);
        System.out.println("result2 : " + result2);

        myCalc.powerOff();
    }
}
```



#### 결과

```java
전원이 켜졌습니다.
result1 : 11
result2 : 2.5
전원이 꺼졌습니다.
```



#### 매개 변수의 수를 모를 경우

여러 개의 수를 모두 합산하는 메소드를 선언해야 한다면, 몇 개의 매개 변수가 입력될지 알 수 없기 때문에 매개 변수의 개수를 결정할 수 없을 것이다. 해결책은 다음과 같이 매개 변수를 배열 타입으로 선언하는 것이다.

```java
 int sum1 ( int[] values ) { }
```

sum1( ) 메소드를 호출할 때 배열을 넘겨줌으로써 배열의 항목 값들을 모두 전달할 수 있다. 배열의 항목 수는 호출할 때 결정된다.

```java
int[] values = { 1, 2, 3 };
int result = sum1(values);
int result = sum1(new int[] { 1, 2, 3, 4, 5 });
```

매개 변수를 배열 타입으로 선언하면, 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다. 그래서 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다. 다음과 같이 sum2( ) 메소드의 매개 변수를 "ㆍㆍㆍ"를 사용해서 선언하게 되면, 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.

```java
int sum2 (int ㆍㆍㆍ values) {  }
```

"ㆍㆍㆍ"로 선언된 매개 변수의 값은 다음과 같이 메소드 호출 시 리스트로 나열해주면 된다.

```java
int result = sum2(1, 2, 3);
int result = sum2(1, 2, 3, 4, 5);
```

"ㆍㆍㆍ"로 선언된 매개 변수는 배열 타입이므로 다음과 같이 배열을 직접 매개밧으로 사용해도 좋다.

```java
int[] values = {1, 2, 3};
int result = sum2(values);
int result = sum2(new int[] { 1, 2, 3, 4, 5}) ;
```

다음 예제는 매개 변수를 배열로 선언한 sum1( )과 매개 변수를 "ㆍㆍㆍ"로 선언한 sum2( )의 작성 방법을 보여준다.



#### 예제 Computer.java ( 매개 변수의 수를 모를 경우 )

```java
public class Computer {
	int sum1(int[] values) {
        int sum = 0;
        for(int i = 0; i < values.length; i++){
            sum += values[i];
        }
        return sum;
    }

    int sum2(int ... values) {
        int sum = 0;
        for(int i = 0; i < values.length; i++){
            sum += values[i];
        }
        return sum;
    }
    
}
```



#### 예제 ComputerExample.java ( 매개 변수의 수를 모를 경우 )

```java
public class ComputerExample {
    public static void main(String[] args) {
        Computer myCom = new Computer();
        
        int[] values1 = {1, 2, 3};
        int result1 = myCom.sum1(values1);
        System.out.println("result1 : " + result1);

        int result2 = myCom.sum1(new int[] {1, 2, 3, 4, 5});
        System.out.println("result2 : " + result2);

        int result3 = myCom.sum2(1, 2, 3);
        System.out.println("result3 : " + result3);

        int result4 = myCom.sum2(1, 2, 3, 4, 5);
        System.out.println("result4 : " + result4);

    }
}
```



#### 결과

```java
result1 : 6
result2 : 15
result3 : 6
result4 : 15
```



#### 리턴(return)문

**리턴값이 있는 메소드**

메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 리턴값을 지정해야 한다. 만약 return문이 없다면 컴파일 오류가 발생한다. return문이 실행되면 메소드는 즉시 종료된다.

```java
return 리턴값;
```

return문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 한다. 예를 들어 리턴 타입인 int인 plus( ) 메소드에서 byte, short, int 타입의 값이 리턴되어도 상관없다. byte 와 short은 int로 자동 타입 변환되어 리턴되기 때문이다.

```java
int plus(int x, int y){						int plus(int x, int y){
	int result = x + y;							byte result = (byte) (x + y);
	return result;								return result;
}											}
```

return문 이후에 실행문이 오면 "Unreachable code"라는 컴파일 오류가 발생한다. 왜냐하면 return문 이후의 실행문은 결코 실행되지 않기 때문이다. 따라서 다음은 잘못된 코딩이다.

```java
int plus(int x, inty) {
	int result = x + y;
	return result;
	System.out.println(result);		//Unreachable code
}
```

하지만 다음과 같은 경우는 컴파일 에러가 발생하지 않는다.

```java
boolean isLeftGas( ) {
	if(gas==0){
		System.out.println("gas가 없습니다.");
		return false;
	}
		System.out.println("gas가 있습니다.");
		return true;
}
```



##### 리턴값이 없는 메소드(void)

void로 선언된 리턴값이 없는 메소드에서도 return문을 사용할 수 있다. 다음과 같이 return문을 사용하면 메소드 실행을 강제 종료시킨다.

```java
return;
```

다음은 gas 값이 0보다 클 경우 계속해서 while문을 실행하고, 0일 경우 return문을 실행해서 run( ) 메소드를 즉시 종료한다. while문이 한 번 루핑할 때마다 gas를 1씩 감소하기 때문에 언젠가는 0이 되어 run( )메소드를 종료한다. 아래 예제에서는 return문 대신 break문을 사용할 수 있다.														만약  while문 뒤에 실행문이 추가적으로 더 있을 경우, break문을 반드시 사용해야 한다. return문은 즉시 메소드를 종료시키기 때문이다.

```java
void run( ) {
	while(true) {
		if(gas > 0) {
			System.out.println("gas가 없습니다.");
			gas -= 1;
		} else {
			System.out.println("gas가 없습니다.");
			return;				//run( )메소드 실행 종료
		}
	}
}
```



#### 예제 Car.java( return문 )

```java
public class Car {
    //필드
    int gas;

    //생성자
    

    //메소드
    void setGas(int gas){           //리턴값이 없는 메소드로 매개값을 받아서 gas 필드값을 변경
        this.gas = gas;
    }

    boolean isLeftGas( ){           //리턴값이 boolean인 메소드로 gas 필드값이 0이면 false를, 0이 아니면 true를 리턴
        if(gas == 0) {
            System.out.println("gas가 없습니다.");
            return false;
        }
            System.out.println("gas가 있습니다.");
            return true;
    }

    void run(){
        while(true){
            if(gas > 0){
                System.out.println("달립니다.(gas잔량 : " + gas + ")");
                gas -= 1;
            } else {
                System.out.println("멈춥니다.(gas잔량 : " + gas + ")");
                return;
           }
        }
    }
}
```



#### 예제 CarExample.java ( return문 )

```java
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car();

        myCar.setGas(5);                            //Car의 setGas( )메소드 호출

        boolean gasState = myCar.isLeftGas();       //Car의 isLeftGas( ) 메소드 호출
        if(gasState){
            System.out.println("출발 합니다.");
            myCar.run();                            //Car의 run( )메소드 호출
        }

        if(myCar.isLeftGas()) {                     //Car의 isLeftGas( )메소드 호출
            System.out.println("gas를 주입할 필요가 없습니다.");
        } else {
            System.out.println("gas를 주입하세요.");
        }
    }
}
```



#### 결과

```java
gas가 있습니다.
출발 합니다.
달립니다.(gas잔량 : 5)
달립니다.(gas잔량 : 4)
달립니다.(gas잔량 : 3)
달립니다.(gas잔량 : 2)
달립니다.(gas잔량 : 1)
멈춥니다.(gas잔량 : 0)
gas가 없습니다.
gas를 주입하세요.
```





#### 메소드 호출

메소드는 클래스 내ㆍ외부의 호출에 의해 실행된다. 클래스 내부의 다른 메소드에서 호출할 경우에는 단순한 메소드 이름으로 호출하면 되지만, 클래스 외부에서 호출할 경우에는 우선 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야 한다. 그 이유는 개체가 존재해야 메소드도 존재하기 때문이다.

![Method2](C:\Users\supre\Desktop\Github\img\Class\Method2.png) 



##### 객체 내부에서 호출

클래스 내부에서 다른 메소드를 호출할 경우에는 다음과 같은 형태로 작성하면 된다. 메소드가 매개변수를 가지고 있을 때에는 매개 변수의 타입과 수에 맞게 매개값을 제공한다.

```java
메소드( 매개값, ㆍㆍㆍ );
```

예를 들어 method2( ) 메소드에서 method1( ) 메소드를 호출하려면 다음과 같이 작성하면 된다.

①호출에서 method1 ("홍길동", 100)이 호출되면 매개값인 "홍길동"은 p1 매개 변수에 대입되고 100은 p2 매개 변수에 대입된다. 그리고 ②실행에서 p1과 p2 변수를 이용하게 된다.

![Method3](C:\Users\supre\Desktop\Github\img\Class\Method3.png)

메소드가 리턴값이 없거나, 있어도 받고 싶지 않을 경우 위와 같이 모두 호출이 가능하다. 리턴값이 있는 메소드를 호출하고 리턴값을 받고 싶다면 다음과 같이 변수를 선언하고 대입하면 된다.

![Method4](C:\Users\supre\Desktop\Github\img\Class\Method4.png)

주의해야 할 점은 변수 타입은 메소드 리턴 타입과 동일하거나, 타입 변환이 될 수 있어야 한다. 예를 들어 int 타입은 double 타입으로 자동 변환되기 때문에 int 리턴값은 double 변수에 대입할 수 있다.

```java
public class ClassName {
	int method1(int x, int y){
		int result = x + y;
		return result;
	}
	
	void method2( ){
		int result1 = method1(10, 20);			//result1에는 30이 저장
		double result2 = method2(10, 20);		//result2에는 30.0이 저장
	}
}
```



#### 예제 Calculator.java ( 클래스 내부에서 메소드 호출 )

```java
public class Calculator {
    int plus(int x, int y) {
        int result = x + y;
        return result;
    }
    
    double avg(int x, int y) {
        double sum = plus(x, y);
        double result = sum / 2;
        return result;
    }

    void excute( ) {
        double result = avg(7, 10);
        prtinln("실행결과: " + result);
    }
    
    void prtinln(String message) {
        System.out.println(message);
    }
    
}
```



#### 예제 CalculatorExample.java ( Calculator의 execute( ) 실행 )

```java
public class CalculatorExample {
    public static void main(String[] args) {
        Calculator myCalc = new Calculator();
        myCalc.excute();
    }
}
```



#### 결과

```java
실행결과: 8.5
```



##### 객체 외부에서 호출

외부 클래스에서 메소드를 호출하려면 우선 다음과 같이 클래스로부터 객체를 생성해야 한다. 메소드는 객체 소속된 멤버이므로 객체가 존재하지 않으면 메소드도 존재하지 않기 때문이다.

```java
클래스 참조변수 = new 클래스(매개값, ㆍㆍㆍ);
```

객체가 생성되었다면 참조 변수와 함께 도트( . ) 연산자를 사용해서 메소드를 호출할 수 있다. 

```java
참조변수.메소드( 매개값, ㆍㆍㆍ );			//리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
타입 변수 = 참조변수.메소드( 매개값, ㆍㆍㆍ ) //리턴값이 있고, 리턴값을 받고 싶을 경우
```

다음은 Car 객체의 keyTrunOn( ) 메소드와 run( ) 메소드를 호출하는 코드이다. keyTurnOn( ) 과 run( ) 메소드는 리턴값이 없기 때문에 단순한 호출만 했고, getSpeed( ) 메소드는 리턴값이 있으므로 리턴값을 받아 변수 speed에 저장했다.

```java
Car myCar = new Car( );
myCar.keyTurnOn( );
myCar.run( );
int speed = myCar.getSpeed( );
```



#### 예제 Car.java( 클래스 외부에서 메소드 호출 )

```java
public class Car {
    //필드
    int gas;

    //생성자
    

    //메소드
    void setGas(int gas){           //리턴값이 없는 메소드로 매개값을 받아서 gas 필드값을 변경
        this.gas = gas;
    }

    boolean isLeftGas( ){           //리턴값이 boolean인 메소드로 gas 필드값이 0이면 false를, 0이 아니면 true를 리턴
        if(gas == 0) {
            System.out.println("gas가 없습니다.");
            return false;
        }
            System.out.println("gas가 있습니다.");
            return true;
    }

    void run(){
        while(true){
            if(gas > 0){
                System.out.println("달립니다.(gas잔량 : " + gas + ")");
                gas -= 1;
            } else {
                System.out.println("멈춥니다.(gas잔량 : " + gas + ")");
                return;
           }
        }
    }
}
```



#### 예제 CarExample.java ( 클래스 외부에서 메소드 호출 )

```java
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car();

        myCar.setGas(5);                            //Car의 setGas( )메소드 호출

        boolean gasState = myCar.isLeftGas();       //Car의 isLeftGas( ) 메소드 호출
        if(gasState){
            System.out.println("출발 합니다.");
            myCar.run();                            //Car의 run( )메소드 호출
        }

        if(myCar.isLeftGas()) {                     //Car의 isLeftGas( )메소드 호출
            System.out.println("gas를 주입할 필요가 없습니다.");
        } else {
            System.out.println("gas를 주입하세요.");
        }
    }
}
```

#### 결과

```java
키를 돌립니다.
달립니다.(시속 : 10km/h)
달립니다.(시속 : 20km/h)
달립니다.(시속 : 30km/h)
달립니다.(시속 : 40km/h)
달립니다.(시속 : 50km/h)
현재 속도 : 50km/h
```



#### 메소드 오버로딩

클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩(overloading)이라고 한다. 하나의 메소드 이름으로 여러 기능을 담는것. 메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다.

![MethodOverloading](C:\Users\supre\Desktop\Github\img\Class\MethodOverloading.png)

메소드 오버로딩이 필요한 이유는 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서이다.

```java
int plus(int x, int y){
	int result = x + y;
	return result;
}
```

다음과 같이 plus( ) 메소도르를 호출하기 위해서는 두 개의  int 매개값이 필요하다. 하지만 int  타입이 아니라  double 타입의 값을 덧셈하기 위해서는 plus( ) 메소도를 호출할 수 없기 때문에  double 타입의 plus( ) 메소드를 더 선언하면 된다.

```java
double plus(double x, double y){
	double result = x + y;
	return result;
}
```

메소드 오버로딩의 가장 대표적인 예는 System.out.println( ) 메소드이다. println( ) 메소드는 호출할 때 주어진 매개값의 타입에 따라서 오버로딩된 println( ) 메소드를 호출한다.다음은 오버로딩된 println( ) 메소드를 보여준다.

```java
void println( ) { .. }
void println( boolean x ) { .. }
void println( char x ) { .. }
void println( char[] x ) { .. }
void println( double x ) { .. }
void println( float x ) { .. }
void println( int x ) { .. }
void println( long x ) { .. }
void println( Object x ) { .. }
void println( String x ) { .. }
```

Calculator 클래스에 areaRectangle( ) 메소드를 오버로딩해서 매개값이 한 개면 정사각형의 넓이를, 두 개이면 직사각형의 넓이를 계산하여 리턴하도록 했다.

#### 예제 Calculator.java( 메소드 오버로딩 )

```java
public class Calculator {
    //정사각형의 넓이
    double areaRectangle(double width){
        return width * width;
    }

    double areaRectangle(double width, double height){
        return width * height;
    }
}
```



#### 예제 CalculatorExample.java ( 메소드 오버로딩 )

```java
public class CalculatorExample {
    public static void main(String[] args) {
        Calculator myCalc = new Calculator();
        
    //정사각형의 넓이 구하기
    double result = myCalc.areaRectangle(10);
    
    //직사각형의 넓이 구하기
    double result2 = myCalc.areaRectangle(10, 20);

        System.out.println("정사각형의 넓이 :" + result);
        System.out.println("직사각형의 넓이 :" + result2);
    }
}
```

#### 결과

```java
정사각형의 넓이 = 100.0
직사각형의 넓이 = 200.0
```



### 인스턴스 멤버와 this

인스턴스(instance) 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체없이는 사용할 수 없다. Car 클래스에 gas 필드와 setSpeed( ) 메소드가 다음과 같이 선언되어 있다고 가정해보자.

```java
public class Car{
	//필드
	int gas;
	
	//메소드
	void setSpeed(int speed){ ㆍㆍㆍ }
}
```

gas 필드와 setSpeed( ) 메소드는 인스턴스 멤버이기 때문에 외부 클래스에서 사용하기 위해서는 우선 Car 객체(인스턴스)를 생성하고 참조 변수 myCar 또는 yourCar로 접근해야 한다.

```java
Car myCar = new Car( );
myCar.gas = 10;
myCar.setSpeed(60);

Car yourCar = new Car( );
yourCar.gas = 20;
yourCar.setSpeed(80);
```

위 코드가 실행된 후 메모리 상태를 그림으로 표현하면 다음과 같다. 

![InstanceThis](C:\Users\supre\Desktop\Github\img\Class\InstanceThis.png)

인스턴스 메소드 setSpeed( )는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다. 객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다. 우리가 자신을 "나"라고 하듯이, 객체는 자신을 "this"라고 한다. 따라서 this.model은 자신이 가지고 있는 model 필드라는 뜻이다. this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용한다.

```java
Car(String model){
	this.model = model;
}

void setModel(String model){
	this.model = model;
}
```



#### 예제 Car.java( 인스턴스 멤버와 this )

```java
public class Car {
    //필드
    String model;
    int speed;

    //생성자
    Car(String model){
        this.model = model;
    }

    //메소드
    void setSpeed(int speed){
        this.speed = speed;
    }

    void run(){
        for(int i = 10; i <= 50; i += 10){
            this.setSpeed(i);
            System.out.println(this.model + "가 달립니다.(시속 : " + this.speed + "km/h)");
        }
    }
}
```



#### 예제 CarExample.java ( 인스턴스 멤버와 this )

```java
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car("포르쉐");
        Car yourCar = new Car("벤츠");
        
        myCar.run();
        yourCar.run();
    }
}
```

#### 결과

```java
포르쉐가 달립니다.(시속 : 10km/h)
포르쉐가 달립니다.(시속 : 20km/h)
포르쉐가 달립니다.(시속 : 30km/h)
포르쉐가 달립니다.(시속 : 40km/h)
포르쉐가 달립니다.(시속 : 50km/h)
벤츠가 달립니다.(시속 : 10km/h)
벤츠가 달립니다.(시속 : 20km/h)
벤츠가 달립니다.(시속 : 30km/h)
벤츠가 달립니다.(시속 : 40km/h)
벤츠가 달립니다.(시속 : 50km/h
```



### 정적 멤버와 static

정적(static)은 '고정된'이란 의미를 가지고 있다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 이들은 각각 정적 필드, 정적 메소드라고 부른다. 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.



#### 정적 멤버 선언

정적 필드와 정적 메소드를 선언하는 방법은 필드와 메소드 선언 시 static 키워드를 추가적으로 붙이면 된다.

```java
public class 클래스{
	//정적 필드
	static 타입 필드 [= 초기값];
	
	//정적 메소드
	static 리턴 타입 메소드( 매개변수선언, ㆍㆍㆍ ) { ㆍㆍㆍ }
}
```



정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.

![staticMember](C:\Users\supre\Desktop\Github\img\Class\staticMember.png)

필드를 선언할 때 인스턴스 필드로 선언할 것인가, 아니면 정적 필드로 선언할 것인가의 판단 기준은 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고, 객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면 정적 필드로 선언하는 것이 좋다. 예를 들어 Calculator 클래스에서 원의 넓이나 둘레를 구할 때 필요한 파이( π )는 Calculator 객체마다 가지고 있을 필요가 없는 변하지 않는 공용적인 데이터이므로 정적 필드로 선언하는 것이 좋다. 그러나 객체별로 색깔이 다르다면 색깔은 인스턴스 필드로 선언해야 한다.

```java
public class Calculator{
	String color;					//계산기별로 색깔이 다를 수 있다.
	static double pi = 3.14159;		//계산기에서 사용하는 파이( π ) 값은 동일하다.
}
```



메소드의 경우, 인스턴스 필드를 이용해서 실행해야 한다면 인스턴스 메소드로 선언하고, 인스턴스 필드를 이용하지 않는다면 정적 메소드로 선언한다. 예를 들어 Calculator 클래스의 덧셈, 뺄셈 기능은 인스턴스 필드를 이용하기보다는 외부에서 주어진 매개값들을 가지고 덧셈과 뺄셈을 수행하는 정적 메소드로 선언하는 것이 좋다. 그러나 인스턴스 필드인 색깔을 변경하는 메소드는 인스턴스 메소드로 선언해야 한다.

```java
public class Calculator {
	String color;												//인스턴스 필드
	void setColor(String color) { this.color = color };			//인스턴스 메소드
	static int plus(int x, int y) { return x + y; }				//정적 메소드
	static int minus(int x, int y) { return x - y; }			//정적 메소드
}
```



#### 정적 멤버 사용

클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 함께 도트( . ) 연산자로 접근한다.

```java
클래스.필드;
클래스.메소드( 매개값 );
```

```java
public class Calculator {
	static double pi = 3.14159;
	static int plus(int x, int y){ ㆍㆍㆍ };
	static int minus(int x, int y){ ㆍㆍㆍ };	
}
```



정적 필드 pi 와 정적 메소드 plus( ), minus( )는 다음과 같이 사용할 수 있다.

```java
double result1 = 10 * 10 * Calculator.pi;
int result2 = Calculator.plus(10, 5);
int result3 = Calculator.minus(10, 5);
```

원칙적으로 클래스 이름으로 접근해야 하지만 다음과 같이 객체 참조변수로도 접근이 가능하다.

```java
Calculator myCalcu = new Calculator( );
double result1 = 10 * 10 * myCalcu.pi;
int result2 = Calculator.plus(10, 5);
int result3 = Calculator.minus(10, 5);
```

하지만 정적 요소는 클래스 이름으로 접근하는 것이 좋다. 이클립스에서는 정적 멤버를 클래스 이름으로 접근하지 않고 객체 참조 변수로 접근했을 경우, 노란색 경고 표시가 나타난다.



#### 예제 Calculator.java ( 정적 멤버 사용 )

```java
public class Calculator {
    static double pi = 3.14159;

    static int plus(int x, int y){
        return x + y;
    }

    static int minus(int x, int y){
        return x - y;
    }
}
```



#### 예제 CalculatorExample.java ( 정적 멤버 사용 )

```java
public class CalculatorExample {
    public static void main(String[] args) {
        double result1 = 10 * 10 * Calculator.pi;
        int result2 = Calculator.plus(10, 5);
        int result3 = Calculator.minus(10, 5);

        System.out.println("result1 : " + result1);
        System.out.println("result2 : " + result2);
        System.out.println("result3 : " + result3);
    }
}
```



#### 결과

```java
result1 : 314.159
result2 : 15
result3 : 5
```



#### 정적 초기화 블록

정적 필드는 다음과 같이 필드 선언과 동시에 초기값을 주는 것이 보통이다.

```java
static double pi = 3.14159;
```

그러나 계산이 필요한 초기화 작업이 있을 수 있다. 인스턴스 필드는 생성자에서 초기화하지만, 정적 필드는 객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 없다. 생성자는 객체 생성 시에만 실행되기 때문이다. 자바는 정적 필드의 복잡한 초기화 작업을 위해서 정적 블록( static block)을 제공한다.

```java
static{
	ㆍㆍㆍ
}
```

정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다. 정적 블록은 클래스 내부에 여러개가 선언되어도 상관없다. 클래스가 메모리로 로딩될 때 선언된 순서대로 실행된다. 다음 예제 Television은 세 개의 정적 필드를 가지고 있는데, company와 model 은 선언 시 초기값을 주었고 info는 초기화하지 않았다. info 필드는 정적 블록에서 company와 model  필드값을 서로 연결해서 초기값으로 설정한다.

#### 예제 Television.java ( 정적 초기화 블록 )

```java
public class Television {
    static String company = "Samsung";
    static String model = "LCD";
    static String info;

    static{
        info = company + " - " + model;
    }
}
```



#### 예제 TelevisionExample.java ( 정적 초기화 블록 )

```java
public class TelevisionExample {
    public static void main(String[] args) {
        System.out.println(Television.info);
    } 
}
```



#### 결과

```java
Samsung - LCD
```



#### 정적 메소드와 블록 선언 시 주의할 점

정적 메소드와 정적 블록을 선언할 때 주의할 점은 **객체가 없어도 실행된다**는 특징 때문에, 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 객체 자신의 참조인 this 키워드도 사용이 불가능하다. 그래서 다음 코드는 컴파일 오류가 발생한다.

```java
public class ClassName{
	//인스턴스 필드와 메소드
	int field1;
	void method1( ) { ㆍㆍㆍ }
	
	//정적 필드와 메소드
	static int field2;
	static void method2( ) { ㆍㆍㆍ }
	
	//정적 블록
	static{
		feild1 = 10;		//컴파일 에러
		method1( );			//컴파일 에러
		field2 = 10;
		method2( );
	}
	
	//정적 메소드
	static void Method3 {
		this.field1 = 10;		//컴파일 에러
		this.method1( );		//컴파일 에러
		field2 = 10;
		method2( );
	}
}
```

정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 다음과 같이 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

```java
static void Method3 {
	ClassName obj = new ClassName( );
		obj.field` = 10;
		obj.method`( );
}
```

main( ) 메소드도 동일한 규칙이 적용된다. main( ) 메소드도 정적(static) 메소드이므로 객체 생성 없이 인스턴스 필드와 인스턴스 메소드를 main( ) 메소드에서 바로 사용할 수 없다. 따라서 다음은 잘못 된 코딩이다.

```java
public class Car{
	int speed;
	
	void run( ) { ㆍㆍㆍ }
	
	public static void main(String[] args){
		speed = 60;		//컴파일 에러
		run( );			//컴파일 에러
	}
}
```

main( ) 메소드를 올바르게 수정하면 다음과 같다.

```java
public static void main(String[] args){
	Car myCar = new Car( );
		myCar.speed = 60;
		myCar.run( );
	}
```



#### 예제 Car.java ( 정적 메소드와 블록 선언 시 주의할 점 )

```java
public class Car{
	int speed;
	
    void run( ) { 
        System.out.println(speed + " 으로 달립니다.");
     }    
    public static void main(String[] args){
        Car myCar = new Car( );
            myCar.speed = 60;
            myCar.run( );
        }
}
```



#### 결과

```java
60 으로 달립니다.
```



#### 싱글톤(Singleton)

가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다. 단 하나만 생성된다고 해서 이 객체를 싱글톤(Singleton)이라고 한다. 싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다. 생성자를 호출한 만큼 객체가 생성되기 때문이다. 생성자를 외부에서 호출할 수 없도록 하려면 생성자 앞에 private 접근 제한자를 붙여주면 된다. 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance( )를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.

```java
public class 클래스 {
	//정적 필드
	private static 클래스 singleton = new 클래스( );
	
	//생성자
	private 클래스( ) { }
	
	//정적 메소드
	static 클래스 getInstance( ) {
		return singleton;
	}
}
```

외부에서 객체를 얻는 유일한 방법은 getInstance( ) 메소드를 호출하는 방법이다. 

```java
클래스 변수1 = 클래스.getInstance( );
클래스 변수2 = 클래스.getInstance( );
```

![Singleton](C:\Users\supre\Desktop\Github\img\Class\Singleton.png)

#### 예제 Singleton.java ( 싱글톤 )

```java
public class Singleton {
    private static Singleton singleton = new Singleton();

    private Singleton( ) { }

    static Singleton getInstance( ){
        return singleton;
    }
}
```



#### 예제 SingletonExample.java ( 싱글톤 객체 )

```java
public class SingletonExample {
    public static void main(String[] args) {
        /*
           Singleton obj1 = new Singleton(); //컴파일 에러
           Singleton obj2 = new Singleton(); //컴파일 에러
        */

        Singleton obj1 = Singleton.getInstance();
        Singleton obj2 = Singleton.getInstance();

        if(obj1 == obj2) {
            System.out.println("같은 Singleton 객체 입니다.");
        } else {
            System.out.println("다른 Singleton 객체 입니다.");
        }
    }
}
```



#### 결과

```java
같은 Singleton 객체 입니다.
```



###  final 필드와 상수

#### final 필드

final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정 할 수 없다는 것이다.

``` java
final 타입 필드 [ = 초기값 ];
```

final 필드의 초기값을 줄 수 있는 방법은 딱 두가지 밖에 없다. 첫 번째는 필드 선언 시에 주는 방법, 두 번째는 생성자에서 주는 방법이다. 생성자는 final 필드의 최종 초기화를 마쳐야 하는데, 만약 초기화되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.

주민등록번호 필드는 한 번 값이 저장되면 변경할 수 없도록 final 필드로 선언했다. 하지만 주민등록번호는 Person 객체가 생성될 때 부여되므로 Person 클래스 설계 시 초기값을 미리 줄 수 없다. 그래서 생성자 매개값으로 주민등록번호를 받아서 초기값으로 지정해 주었다. 반면 nation은 항상 고정된 값을 갖기 때문에 필드 선언 시 초기값으로 "Korea"를 주었다.



#### 예제 Person.java ( final 필드 선언과 초기화 )

```java
public class Person {
    final String nation = "Korea";
    final String ssn;
    String name;

    public Person(String ssn, String name){
        this.ssn = ssn;
        this.name = name;
    }
}
```



#### 예제 PersonExample.java ( final 필드 테스트 )

```java
public class PersonExample {
    public static void main(String[] args) {
        Person p1 = new Person("123456-1234567", "supreme0122");

        System.out.println(p1.nation);
        System.out.println(p1.ssn);
        System.out.println(p1.name);

        //p1.nation = "usa";                //final 필드는 값 수정 불가
        //p1.ssn =  "654321 - 7654321";     //final 필드는 값 수정 불가
        p1.name = "github";
    }
}
```



#### 결과

```java
Korea
123456-1234567
supreme0122
```



#### 상수 ( static fianl )

일반적으로 불변의 값을 상수라고 부른다. 불변의 값이라고 한다면 수학에서 사용되는 원주율 파이( π )나, 지구의 무게 및 둘레 등이 해당된다. fianl 필드를 상수라고 부르지 않는 이뉴는 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띠고 있으며, 여러 가지 값으로 초기화 될 수 없기 때문이다. final 필드는 객체마다 저장되고, 생성자의 매개값을 통해서 여러 가지 값을 가질 수 있기 때문에 상수가 될 수 없다.  초기값이 단순 값이라면 선언 시에 주는 것이 일반적이지만, 복잡한 초기화일 경우 정적 블록에서도 할 수 있다.

```java
static final 타입 상수 [ = 초기값 ];

static final 타입 상수;
static {
	상수 = 초기값;
}
```

상수 이름은 모두 대문자로 작성하는 것이 관례적이다. 만약 서로 다른 단어가 혼합된 이름이라면 언더바( _ )로 단어들을 연결해준다.

```java
static final double PI = 3.14159;
static final double EARTH_SURFACE_AREA;
```



#### 예제 Earth.java ( 상수 선언 )

```java
public class Earth {
    static final double EARTH_RADIUS = 6400;
    static final double EARTH_SURFACE_AREA;

    static {
        EARTH_SURFACE_AREA = 4 * Math.PI * EARTH_RADIUS * EARTH_RADIUS;
    }
}
```



#### 예제EarthExample.java ( 상수 사용 )

```java
public class EarthExample {
    public static void main(String[] args) {
        System.out.println("지구의 반지름 : " + Earth.EARTH_RADIUS + " km");
        System.out.println("지구의 표면적 : " + Earth.EARTH_SURFACE_AREA + " km^2");
    }
}
```



#### 결과

```java
지구의 반지름 : 6400.0 km
지구의 표면적 : 5.147185403641517E8 km^2
```



### 접근 제한자

main( ) 메소드를 가지지 않는 대부분의 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스이다. 라이브러리 클래스를 설계할 때에는 외부 클래스에서 접근할 수 있는 멤버와 접근 할 수 없는 멤버로 구분해서 필드, 생성자, 메소드를 설계하는 것이 바람직하다. 접근 제한자는 public, protected, default, private와 같이 네 가지 종류가 있다.



- public : 외부 클래스가 자유롭게 사용할 수 있는 공개 멤버
- protected : 같은 패키지 또는 자식 클래스에서 사용할 수 있는 멤버
- private : 외부에 노출되지 않는 멤버
- default : 위 세 가지 접근 제한자가 적용되지 않은 멤버



| 접근 제한 | 적용 대상                    | 접근할 수 없는 클래스                          |
| --------- | ---------------------------- | ---------------------------------------------- |
| public    | 클래스, 필드, 생성자, 메소드 | 없음                                           |
| protected | 필드, 생성자, 메소드         | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default   | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스                    |
| private   | 필드, 생성자, 메소드         | 모든 외부 클래스                               |



#### 클래스의 접근 제한

클래스 선언 시 고려해야 할 사항은 같은 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 한다. 클래스에 적용할 수 있는 접근 제한은 public 과 default  단 두 가지이다.

```java
//default 접근 제한
class 클래스 { ㆍㆍㆍ };

//public 접근 제한
public class 클래스 { ㆍㆍㆍ };
```



##### default 접근 제한

클래스를 선언할 때 public을 생략했다면 클래스는 default 접근 제한을 가진다. 클래스가 default 접근 제한을 가지게 되면 같은 패키지에서는 아무런 제한 없이 사용할 수 있지만 다른 패키지에서 사용할 수 없다.

![default](C:\Users\supre\Desktop\Github\img\Class\default.png)

#####  public 접근 제한

클래스가 public 접근 제한을 가지게 되면 같은 패키지뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용할 수 있다. 

![public](C:\Users\supre\Desktop\Github\img\Class\public.png)

#### 예제 A.java ( 클래스의 접근 제한 )

```java
package exam01_class.package1;

class A { }         //default 접근 제한
```



#### 예제 B.java ( 클래스의 접근 제한 )

```java
package exam01_class.package1;		//패키지가 동일

public class B {
    A a;        //A 캘래스 접근 가능(필드로 선언할 수 있음)
}
```

B 클래스는 A 클래스와 같은 패키지이므로 A 클래스에 접근이 가능하다. 그래서 B 클래승레서 A클래스를 이용하여 필드 선언 및 생성자/메소드 내부에서 변수 선언이 가능하다.



#### 예제 C.java ( 클래스의 접근 제한 )

```java
package exam01_class.package2;		//패키지가 다름
import exam01_class.package1.*;

public class C {            
    A a;    //(x)           //A 클래스 접근 불가(컴파일 에러)
    B b;    //(o)
}
```

C 클래스는 A클래스와 다른 패키지이므로  default 접근이 제한된 A 클래스에는 접근이 되지 않지만, public으로 공개된 B 클래스는 접근이 가능하다. 그래서 C클래스에서 B클래스를 이용하여 필드 선언 및 생성자/메소드 내부에서 변수 선언이 가능하다.



#### 생성자의 접근 제한

생성자가 어떤 접근 제한을 갖느냐에 따라 호출 기능 여부가 결정된다.

```````java
public class ClassName {
	//public 접근 제한
	public ClassName ( ㆍㆍㆍ ) { ㆍㆍㆍ }

	//protected 접근 제한
	protected ClassName ( ㆍㆍㆍ ) { ㆍㆍㆍ }
	
	//default 접근 제한
	ClassName ( ㆍㆍㆍ ) { ㆍㆍㆍ }
	
	//private 접근 제한
	private ClassName ( ㆍㆍㆍ ) { ㆍㆍㆍ }
}
```````

 

| 접근 제한자 | 생성자         | 설명                                                         |
| ----------- | -------------- | ------------------------------------------------------------ |
| public      | 클래스(ㆍㆍㆍ) | **모든 패키지에서 아무런 제한 없이 생성자를 호출할 수 있도록 한다.** <br />클래스가 default 접근 제한을 가진다면 클래스 사용이 같은 패키지로 한정되므로, <br />비록 **생성자가 public 접근 제한을 가지더라도 같은 패키지에서만 생성자를 호출 할 수있다.** |
| protected   | 클래스(ㆍㆍㆍ) | default 접근 제한과 마찬가지로 같은 패키지에 속하는 클래스에서 생성자를 호출할 수 있다. <br />**차이점은 다른 패키지에 속한 클래스가 해당 클래스의 자식(child) 클래스라면<br />생성자를 호출할 수 있다.** |
| default     | 클래스(ㆍㆍㆍ) | default 접근 제한은 **같은 패키지에서는 아무런 제한 없이 생성자를 호출할 수 있으나, <br />다른 패키지에서는 생성자를 호출할 수 없도록 한다.** |
| private     | 클래스(ㆍㆍㆍ) | 동일 패키지이건 다른 패키지이건 상관없이 생성자를 호출하지 못하도록 제한한다. <br />따라서 클래스 외부에서 new 연산자로 객체를 만들수 없다. <br />오로지 **클래스 내부에서만 생성자를 호출할 수 있고, 객체를 만들 수 있다.** |



#### 예제 A.java ( 생성자의접근 제한 )

```java
package exam01_class.package1;

public class A {
    //필드
    A a1 = new A(true);         //(o)
    A a2 = new A(1);            //(o)
    A a3 = new A("문자열");     //(o)

    //생성자
    public A(boolean b) { }         //public 접근 제한
    A(int b) { }                    //default 접근 제한
    private A(String s) { }         //private 접근 제한
}
```

A 클래스 내부에서는 A의 모든 생성자를 호출할 수 있다.



#### 예제 B.java ( 생성자의 접근 제한 )

```java
package exam01_class.package1;		//패키지가 동일

public class B {
     //필드
     A a1 = new A(true);         //(o)
     A a2 = new A(1);            //(o)
     A a3 = new A("문자열");     //(x)  private 생성자 접근 불가(컴파일 에러)
}
```

패키지가 동일한 B 클래스에서는 A 클래스의 private 생성자를 제외하고 다른 생성자를 호출할 수 있다. 



#### 예제 C.java ( 생성자의 접근 제한 )

```java
package exam01_class.package2;		//패키지가 다름
import exam01_class.package1.*;

public class C {
     //필드
     A a1 = new A(true);         //(o)
     A a2 = new A(1);            //(x)      default 생성자 접근 불가(컴파일 에러)
     A a3 = new A("문자열");     //(x)      private 생성자 접근 불가(컴파일 에러)
 }
```

패키지가 다른 C 클래스에서는 A 클래스의 public 생성자를 제외하고 다른 생성자를 호출할 수 없다.

가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다. 이럴 경우 여러개의 객체를 만들지 못하도록 설계해야 하는데 이것을 싱글톤(Singleton) 패턴이라고 한다. 싱글톤 패턴은 생성자를 private 접근제한으로 선언하고, 자신의 유일한 객체를 리턴하는 getInstance( ) 정적 메소드를 선언하는 것을 말한다.



#### 필드와 메소드의 접근 제한

필드와 메소드를 선언할 때 고려해야 할 사항은 클래스 내부에서만 사용할 것인지, 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 한다. 이것은 필드와 메소드가 어떤 접근 제한자를 갖느냐에 따라 결정된다.



| 접근 제한자 | 생성자                    | 설명                                                         |
| ----------- | ------------------------- | ------------------------------------------------------------ |
| public      | 필드 <br />메소드(ㆍㆍㆍ) | **모든 패키지에서 아무런 제한 없이 필드와 메소드를 호출할 수 있도록 한다.** <br />필드와 메소드가 public 접근 제한을 가질 경우 클래스도 public 접근 제한을 가져야 한다.<br />클래스가 default 접근 제한을 가지게 되면 같은 패키지 안에서만 클래스가 사용되기 때문이다. |
| protected   | 필드 <br />메소드(ㆍㆍㆍ) | default 접근 제한과 마찬가지로 같은 패키지에 속하는 클래스에서 필드와 메소드를 호출할 수 있다. <br />**차이점은 다른 패키지에 속한 클래스가 해당 클래스의 자식(child) 클래스라면<br />필드와 메소드를 호출할 수 있다.** |
| default     | 필드 <br />메소드(ㆍㆍㆍ) | default 접근 제한은 **같은 패키지에서는 아무런 제한 없이 필드와 메소드를 호출할 수 있으나, <br />다른 패키지에서는 필드와 메소드를 호출할 수 없도록 한다.** |
| private     | 필드 <br />메소드(ㆍㆍㆍ) | 동일 패키지이건 다른 패키지이건 상관없이 필드와 메소드를호출하지 못하도록 제한한다. <br />오로지 **클래스 내부에서만 사용할 수 있다.** |

#### 예제 A.java ( 생성자의접근 제한 )

```java
package exam01_class.package1;

public class A {
    //필드
    public int field1;              //public 접근 제한
    int field2;                     //default 접근 제한
    private int field3;             //private 접근 제한

    //생성자
    public A( ) {           //클래스 내부일 경우 접근 제한자의 영향을 받지 않는다.
        field1 = 1;     //(o)
        field2 = 1;     //(o)
        field3 = 1;     //(o)
        
        method1( );     //(o)
        method2( );     //(o)
        method3( );     //(o)
    }

    //메소드
    public void method1( ) { }      //public 접근 제한
    void method2( ) { }             //default 접근 제한
    private void method1( ) { }     //private 접근 제한
}
```

A 클래스 내부에서는 A의 모든 생성자를 호출할 수 있다.



#### 예제 B.java ( 생성자의 접근 제한 )

```java
package exam01_class.package1;		//패키지가 동일

public class B {
    public B( ) {
        A a = new A( );
        a.field1 = 1;     //(o)
        a.field2 = 1;     //(o)
        a.field3 = 1;     //(x)         //private 필드 접근 불가(컴파일 에러)
        
        a.method1( );     //(o)
        a.method2( );     //(o)
        a.method3( );     //(x)         //private 메소드 접근 불가(컴파일 에러)
    }
}
```

패키지가 동일한 B 클래스에서는 A 클래스의 private 생성자를 제외하고 다른 생성자를 호출할 수 있다. 



#### 예제 C.java ( 생성자의 접근 제한 )

```java
package exam01_class.package2;		//패키지가 다름
import exam01_class.package1.*;

public class C {
    public C( ) {
        A a = new A( );
        a.field1 = 1;     //(o)
        a.field2 = 1;     //(x)         //default 필드 접근 불가(컴파일 에러)
        a.field3 = 1;     //(x)         //private 필드 접근 불가(컴파일 에러)
        
        a.method1( );     //(o)
        a.method2( );     //(x)         //default 필드 접근 불가(컴파일 에러)
        a.method3( );     //(x)         //private 메소드 접근 불가(컴파일 에러)
    }
}
```



### Getter와 Setter 메소드

일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체의 외부에서 직접적으로 접근하는 것을 막는다. 그 이유는 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성(결점이 없는 성질)이 깨어질 수 있기 때문이다. 예를 들어 자동차의 속도는 음소가 될 수 없는데, 외부에서 음수로 변경하면 객체의 무결성이 깨진다. 신제로 다음 코드는 Car 객체의 speed 필드값을 -100으로 변경시킨다.

```java
 myCar.speed = -100;
```

이러한 문제점을 해결하기 위해 객체 지향 프로그래밍에서는 메소드를 통해서 데이터를 변경하는 방법을 선호한다. 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다. 그 이유는 메소드 매개값을 검증해서 유효한 값만 데이터로 저장할 수 있기 때문이다. 이러한 역할을 하는 메소드가 Setter이다. 예를 들어 자동차의 속도를 setSpeed( ) 메소드로 변경할 경우 다음과 같이 검증 코드를 작성할 수 잇다.

```java
void setSpeed(double speed) {
	if(speed < 0) {
		this.speed = 0;		//매개값이 음수일 경우 speed필드에 0으로 저장하고, 메소드 실행 종료
		return;
	} else {
		this.speed = speed;
	}
}
```

외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다. 객체 외부에서 객체의 필드값을 사용하기에 부적잘한 경우도 있다. 이런 경우에는 메소드로 필드값을 가공한 후 외부로 전달하면 된다. 이런 메소드가 바로 Getter이다. 예를 들어 자동차의 속도를 마일에서 KM 단위로 환산해서 외부로 리턴해주는 getSpeed( ) 메소드를 같이 작성할 수 있다.

```java
double getSpeed( ) {		//필드값인 마일을 km 단위로 환산 후 외부로 리턴
	double km = speed * 1.6;
	return km;
}
```

클래스를 선언할 때 가능하다면 필드를 private로 선언해서 외부로부터 보호하고, 필드에 대한 Setter 와 Getter 메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋다. 다음은 Setter와 Getter 메소드를 선언하는 방법을 보여준다.

```java
private  타입 fieldName;			//필드 접근 제한자 : private

//Getter
public 리턴 타입 getFieldName( ) {
	return fieldName;
	//접근 제한자 : public
	//리턴 타입 : 필드타입
	//메소드 이름 : get + 필드이름(첫문자 대문자)
	//리턴값 : 필드값
	
//Setter
public void setFieldName( 타입 fieldName ) {
	this.fieldName = fieldName;
	//접근 제한자 : public
	//리턴 타입 : void
	//메소드 이름 : set + 필드이름(첫문자 대문자)
	//매개 변수 타입 : 필드타입
}
```

필드 타입이 boolean일 경우에는 Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례이다. 예를 들어 stop필드의 Getter와 Setter는 다음과 같이 작성할 수 있다.

```java
private  boolean stop;			//필드 접근 제한자 : private

//Getter
public boolean isStop( ) {
	return stop;
	//접근 제한자 : public
	//리턴 타입 : 필드타입
	//메소드 이름 : is + 필드이름(첫문자 대문자)
	//리턴값 : 필드값
	
//Setter
public void setStop( boolean stop ) {
	this.stop = stop;
	//접근 제한자 : public
	//리턴 타입 : void
	//메소드 이름 : set + 필드이름(첫문자 대문자)
	//매개 변수 타입 : 필드타입
}
```

만약 외부에서 필드값을 읽을 수만 있고 변경하지 못하도록 하려면( 읽기 전용 ) Getter 메소드만 선언해도 좋고, 아니면 Setter 메소드를 private 접근 제한을 갖도록 선언해도 좋다. 



#### 예제 Car.java ( Getter 와 Setter 메소드 선언 )

```java
public class Car{
    //필드
    private int speed;
    private boolean stop;

    //생성자

    //메소드
    public int getSpeed( ) {
        return speed;
    }

    public void setSpeed(int speed) {
        if(speed < 0){
            this.speed = 0;
            return;
        } else {
            this.speed = speed;
        }
    }

    public boolean isStop( ) {
        return stop;
    }

    public void setStop(boolean stop){
        this.stop = stop;
        this.speed = 0;
    }
}
```



#### 예제 CarExample.java ( Getter 와 Setter 메소드 사용 )

```java
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car( );

        //잘못된 속도 변경
        myCar.setSpeed(-50);

        System.out.println("현재 속도 : " + myCar.getSpeed());

        //올바른 속도 변경
        myCar.setSpeed(60);

        //멈춤
        if(!myCar.isStop()){
            myCar.setStop(true);
        }

        System.out.println("현재 속도 : " + myCar.getSpeed());
    }
}
```



#### 결과

```java
현재 속도 : 0
현재 속도 : 0
```



### 어노테이션

어노테이션(Annotation)은 메타데이터(metadata)라고 볼 수 있다. 메타데이터란 애플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다.

```java
@AnnotationName		//어노테이션의 작성방법
```

어노테이션은 다음 세 가지 용도로 사용된다.

- 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
- 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
- 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공하는 대표적인 예는 @Override 어노테이션이다. @Override는 메소드 선언 시 사용하는데, 메소드가 오버라이드 (재정의)된 것임을 컴파일러에게 알려주어 컴파일러가 오버라이드 검사를 하도록 해준다. 정확히 오버라이드가 되지 않았다면 컴파일러는 에러를 발생시킨다. 어노테이션은 빌드 시 자동으로 XML 설정 파일을 생성하거나, 배포를 위해 JAR 압축 파일을 생성하는데에도 사용된다. 클래스의 역할을 정의 하기도 한다.

#### 어노테이션 타입 정의와 적용

어노테이션 타입을 정의하는 방법은 인터페이스를 정의하는 것과 유사하다. 다음과 같이 @interface를 사용해서 어노테이션을 정의하며, 그 뒤에 사용할 어노테이션 이름이 온다.

```java
public @interface AnnotationName{
}
```

**이렇게 정의한 어노테이션은 코드에서 다음과 같이 사용한다.**

```java
@AnnotationName
```

어노테이션은 엘리먼트(element)를 멤버로 가질 수 있다. 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.

```java
public @interface AnnotationName{
	타입 elementName( ) [default 값];			//엘리먼트 선언
    ㆍㆍㆍ
}
```

엘리먼트의 타입으로는 int나 double과 같은 기본 데이터 타입이나 String, 열거 타입, Class 타입, 그리고 이들의 배열 타입을 사용할 수 있다. 엘리먼트의 이름 뒤에는 메소드를 작성하는 것처럼( )를 붙여야 한다. 예를 들어 String 타입의 엘리먼트와 int 타입의 엘리먼트를 다음과 같이 선언할 수 있다.

```java
public @interface AnnotationName{
	String elementName1( );
	int elementName2( ) default 5;
}

@AnnotationName(elementName1 = "값", elementName2 = 3);
또는
@AnnotationName(elementName1 = "값");
```

elementName1은 디폴트 값이 없기 때문에 반드시 값을 기술해야 하고, elementName2는 디폴트 값이 있기 때문에 생략 가능하다. 어노테이션은 기본 엘리먼트인 value를 가질 수 있다.

```java
public @interface AnnotationName{
	String value( );			//기본 엘리먼트 선언
	int elementName( ) default 5;
}
```

Value 엘리먼트를 가진 어노테이션을 코드에서 적용할 때에는 다음과 같이 값만 기술할 수 있다.

이 값은 기본 엘리먼트인 value 값으로 자동 설정된다.

```java
@AnnotationName("값");
```

만약 value 엘리먼트와 다른 엘리먼트의 값을 동시에 주고 싶다면 다음과 같이 정상적인 방법으로 지정하면 된다.

```java
@AnnotationName(value="값", elementName=3);
```



#### 어노테이션 적용 대상

어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType 열거 상수로 다음과 같이 정의되어 있다.

| ElementType 열거 상수 | 적용 대상                    |
| --------------------- | ---------------------------- |
| TYPE                  | 클래스, 인터프에스, 열거타입 |
| ANNOTATION_TYPE       | 어노테이션                   |
| FIELD                 | 필드                         |
| CONSTRUCTOR           | 생성자                       |
| METHOD                | 메소드                       |
| LOCAL_VARIABLE        | 로컬 변수                    |
| PACKAGE               | 패키지                       |

어노테이션이 적용될 대상을 지정할 때에는 @Targer 어노테이션을 사용한다. @Target의 기본 엘리먼트인 value는 ElementType 배열을 값으로 가진다. 이것은 어노테이션이 적용될 대상을 복수개로 지정하기 위해서이다.

```java
@Targer({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
public @interface AnnotationName{
}
```

다음과 같이 클래스, 필드, 메소드만 어노테이션을 적용할 수 있고 생성자는 적용할 수 없다.

```java
@AnnotationName
public class ClassName{
	@AnnotationName
	private String fieldName;
	
	//@AnnotationName (x)			//@Targer에 CONSTRUCT가 없어 생성자는 적용 못함
	public ClassName( ) { }
	
	@AnnotationName
	public void methodName( ) { }
}
```



#### 어노테이션 유지 정책

어노테이션 정의 시 한 가지 더 추가해야 할 내용은 사용 용도에 다라 @AnnotationName을 어느 범위까지 유지할 것인지 지정해야 한다. 쉽게 설명하면 소스상에만 유지할 건지, 컴파일된 클래스까지 유지할 건지, 런타임 시에도 유지할 건지를 지정해야 한다. 어노테이션 유지 정책은 java.lang.annotation.RetentionPolicy 열거 상수로 다음과 같이 정의되어 있다.

| RetentionPolicy 열거 상수 | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| SOURCE                    | 소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다. |
| CLASS                     | 바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다. |
| RUNTIME                   | 바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임시 어노테이션 정보를 얻을 수 있다. |

리플렉션(Reflection)이란 런타임 시에 클래스의 메타 정보를 얻는 기능을 말한다. 예를 들어 클래스가 가지고 있는 필드가 무엇인지, 어떤 생성자를 갖고 있는지, 어떤 메소드를 가지고 있는지, 적용된 어노테이션이 무엇인지 알아내는 것이 리플렉션이다. 리플렉셕을 이용해서 런타임 시에 어노테이션 정보를 얻으려면 어노테이션 유지 정책을 RUNTIME으로 설정해야 한다. 어노테이션 유지 정책을 지정할 때에는 @Retention 어노테이션을 사용한다. @Retention의 기본 엘리먼트인 value는 RetentionPolicy 타입이므로 위 세 가지 상수 중 하나를 지정하면 된다. 코드 자동 생성 툴을 개발하지 않는 이상 우리가 작성하는 어노테이션은 대부분 런타임 시점에 사용하기 위한 용도로 만들어진다.

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationName{
}
```



#### 런타임 시 어노테이션 정보 사용하기

런타임 시에 어노테이션이 적용되었는지 확인하고 엘리먼트 값을 이용해서 특정 작업을 수행하는 방법에 대해 알아보자. 어노테이션 자체는 아무런 동작을 가지지 않는 단지 표식일 뿐이지만, 리플렉션을 이용해서 어노테이션의 적용 여부와 엘리먼트 값을 읽고 적절히 처리할 수 있따. 클래스에 적용된 어노테이션 정보를 얻으려면 java.lang.Class를 이용하면 되지만, 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class의 다음 메소드를 통해서 java.lang.reflect 패키지의 Field, Constructor, Method 타입의 배열을 얻어야 한다.

| 리턴 타입      | 메소드명(매개 변수)   | 설명                                 |
| -------------- | --------------------- | ------------------------------------ |
| Field[ ]       | getFields( )          | 필드 정보를 Field배열로 리턴         |
| Constructor[ ] | getConstructors( )    | 생성자 정보를 Constuctor 배열로 리턴 |
| Method[ ]      | getDeclaredMethods( ) | 메소드 정보를 Method 배열로 리턴     |

그런 다음 Class, Field, Constructor, Method가 가지고 있는 다음 메소드를 호출해서 적용된 어노테이션 정보를 얻을 수 있다.

| 리턴 타입     | 메소드명(매개 변수)                                          |
| ------------- | ------------------------------------------------------------ |
| boolean       | isAnnotationPresent(Class<? extends Annotation > annotationClass) |
|               | 지정한 어노테이션이 적용되었는지 여부. Class에서 호출했을 때 상위 클래스에 적용된 경우에도 true를 리턴한다. |
| Annotation    | getAnnotation(Class<T> annotationClass)                      |
|               | 지정한 어노테이션이 적용되어 있으면 어노테이션을 리턴하고 그렇지 않다면 null을 리턴한다. <br />Class에서 호출했을 때 상위 클래스에 적용된 경우에도 어노테이션을 리턴한다. |
| Annotation[ ] | getAnnotations( )                                            |
|               | 적용된 모든 어노테이션을 리턴한다. Class에서 호출했을 때 상위 클래스에 적용된 어노테이션도 모두 포함한다.<br />적용된 어노테이션이 없을 경우 길이가 0인 배열을 리턴한다. |
| Annotation[ ] | getDeclaredAnnotations( )                                    |
|               | 직접 적용된 모든 어노테이션을 리턴한다. <br />Class에서 호출했을 때 상위 클래스에 적용된 어노테이션은 포함되지 않는다. |

어노테이션과 리플렉션을 이용해서 간단한 예제를 만들어 보면 다음 각 메소드의 실행 내용을 구분선으로 분리해서 콘솔에 출력하는 PrintAnnotaition이다.



#### 예제 PrintAnnotation.java ( 어노테이션 정의 )

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface PrintAnnotation {
    String value() default "-";
    int numeber() default 15;
}
```



#### 예제 Service.java ( 어노테이션 적용 클래스 )

```java
public class Service {
    @PrintAnnotation
    public void method1(){
        System.out.println("실행 내용1");
    }
    @PrintAnnotation("*")
    public void method2(){
        System.out.println("실행 내용2");
    }
    @PrintAnnotation(value="#", numeber = 20)
    public void method3(){
        System.out.println("실행 내용3");
    }
}
```



#### 예제 PrintAnnotationExample.java ( 어노테이션 결과 출력 )

```java
import java.lang.reflect.Method;

public class PrintAnnotationExample {
    public static void main(String[] args) {
        //Service 클래스로부터 메소드 정보를 얻음
        Method[] declaredMethods = Service.class.getDeclaredMethods();      //Service 클래스에 선언된 메소드 얻기(리플렉션)

        //Method 객체를 하나씩 처리
        for(Method method : declaredMethods){
            //PrintAnnotation이 적용되었는지 확인
            if(method.isAnnotationPresent(PrintAnnotation.class)){
                //PrintAnnotation 객체 얻기
                PrintAnnotation printAnnotation = method.getAnnotation(PrintAnnotation.class);

                //메소드 이름 출력
                System.out.println("[ " + method.getName() + " ]");
                //구분선 출력
                for(int i = 0; i < printAnnotation.numeber(); i++){
                    System.out.print(printAnnotation.value());
                }
                System.out.println();

                try{
                    //메소드 호출
                    method.invoke(new Service());
                } catch (Exception e) {
                    System.out.println();
                }
                
            }
        }
    }
}
```



#### 결과

```java
[ method1 ]
---------------
실행 내용1
[ method2 ]
***************
실행 내용2
[ method3 ]
####################
실행 내용3
```

