# 상속(Inheritance)

## 1. 상속 개념

상속은 부모가 자식에게 물려주는 행위를 말한다. 자식은 상속을 통해서 무모가 물려준 것을 자연스럽게 이용할 수 있다. 자바에서는 부모 클래스(상위클래스), 자식 클래스(하위 클래스)라고 표현한다.

![Inheritance](C:\Users\samsung\OneDrive\바탕 화면\Github\img\Inheritance\Inheritance.png)

상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다. field1, field2, method1( ), method2( )를 가지는 클래스를 작성했다고 가정하고 4개를 모두 처음부터 작성하는 것보다는 field1과  method1( )을 가지고 있는 클래스가 있다면 이것을 상속하고 field2, method2( )만 추가 작성하는 것이 효율적이고 개발시간을 절약시킨다.

![Inheritance2](C:\Users\samsung\OneDrive\바탕 화면\Github\img\Inheritance\Inheritance2.png)

실제로 B 클래스를 객체 생성해서 다음과 같이 사용할 때에는 마치 B가 field1( )과 method1( )을 가지고 있는 것 처럼 보인다.

```java
B b = new B( );
b.field1 = 10;				// A로부터 물려받은 필드와 메소드
b.method( );

b.field2 = "홍길동";			// B가 추가한 필드와 메소드
b.method2( );
```

부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다. 그리고 부모 클래스와 자식클래스가 다른 패키지에 존대한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다. 



## 2. 클래스 상속

현실에서는 부모가 자식을 선택하지만, 프로그램(자바)에서는 자식이 부모를 선택한다. 자식이 부모클래스를 선택할 때에는 다음과 같이 선택한다.

```java
class 자식클래스 extends 부모클래스 {
	//필드
	//생성자
	//메소드
}

 class SportCar extends Car {
     //Car 클래스를 상속해서 SportsCar 클래스를 설계한다.
 }
```

다른 언어와 달리 **자바는 다중 상속을 허용하지 않는다.** 

다음은 핸드폰( Cellphone ) 클래스를 상속해서 DMB폰( DmbCellPhone ) 클래스를 작성한 것이다. 핸드폰이 부모 클래스가 되고, DMB폰이 자식 클래스가 된다.



#### 예제 CellPhone.java( 부모 클래스 )

```java
public class CellPhone {
    //필드
    String model;
    String color;

    //생성자

    //메소드
    void powerOn() {
        System.out.println("전원을 켭니다.");
    }

    void powerOff() {
        System.out.println("전원을 끕니다.");
    }

    void bell() {
        System.out.println("벨이 울립니다.");
    }

    void sendVoice(String message) {
        System.out.println("나 : " + message);
    }

    void receiveVoice(String message) {
        System.out.println("상대방 : " + message);
    }

    void hangUp() {
        System.out.println("전화를 끊습니다.");
    }
}
```



#### 예제 DmbCellPhone.java( 자식 클래스 )

```java
import java.lang.reflect.Method;

public class DmbCellPhone extends CellPhone {
    //필드
    int channel;

    //생성자
    DmbCellPhone(String model, String color, int channel){
        this.model = model;         //CellPhone으로부터 상속받은 필드
        this.color = color;         //CellPhone으로부터 상속받은 필드
        this.channel = channel;
    }

    //메소드
    void turnOnDmb() {
        System.out.println("채널 " + channel + "번 DMB 방송 수신을 시작합니다.");
    }

    void changeChannelDmb(int channel) {
        System.out.println("채널 " + channel + "번 으로 바꿉니다..");
    }

    void turnOffDmb() {
        System.out.println("DMB 방송 수신을 멈춥니다.");
    }
}

```



#### 예제 DmbCellPhoneExample.java( 자식 클래스 사용 )

```java
public class DmbCellPhoneExample {
    public static void main(String[] args) {
        //DmbCellPhone 객체 생성
        DmbCellPhone dmbCellPhone = new DmbCellPhone("자바폰", "검정", 10);

        //CellPhone으로부터 상속받은 필드
        System.out.println("모델 : " + dmbCellPhone.model);
        System.out.println("색상 : " + dmbCellPhone.color);

        //DmbCellPhone의 필드
        System.out.println("채널 : " + dmbCellPhone.channel);

        //CellPhone으로부터 상속받은 메소드 호출
        dmbCellPhone.powerOn();
        dmbCellPhone.bell();
        dmbCellPhone.sendVoice("여보세요");
        dmbCellPhone.receiveVoice("안녕하세요 저는 홍길동인데요");
        dmbCellPhone.sendVoice("그런데요?");
        dmbCellPhone.hangUp();

        //DmbCellPhone의 메소드 호출
        dmbCellPhone.turnOnDmb();
        dmbCellPhone.changeChannelDmb(12);
        dmbCellPhone.turnOffDmb();
    }
}

```

#### 

#### 결과

```java
색상 : 검정
채널 : 10
전원을 켭니다.
벨이 울립니다.
나 : 여보세요
상대방 : 안녕하세요 저는 홍길동인데요
나 : 그런데요?
전화를 끊습니다.
채널 10번 DMB 방송 수신을 시작합니다.
채널 12번 으로 바꿉니다..
DMB 방송 수신을 멈춥니다.
```



## 3. 부모 생성자 호출

자바에서 자식 객체를 생성하려면, 부모 객체가 먼저 생성되어야 한다. 아래 코드는 DmbCellPhone 객체만 생성하는 것처럼 보이지만, 사실은 내부적으로 부모인 CellPhone 객체가 먼저 생성되고, DmbCellPhone 객체가 생성된다.

```java
DmbCellPhone dmbCellPhone = new DmbCellPhone( );
```

이것을 메모리로 표현하면 다음과 같다.

![Inheritance3](C:\Users\samsung\OneDrive\바탕 화면\Github\img\Inheritance\Inheritance3.png)

자바의 모든 객체는 클래스의 생성자를 호출해야만 생성된다. 그렇다면 부모객체를 생성하기 위해 부모 생성자를 어디서 호출한 것일까? 이것에 대한 비밀은 자식 생성자에 숨어 있다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출 된다. 예를 들어 DmbCellPhone의 생성자가 명시적으로 선언되지 않았다면 **컴파일러는 다음과 같은 기본 생성자를 생성해 낸다.**

```java
public DmbCellPhone() {
	super( );
}
```

super( )는 부모의 기본 생성자를 호출한다.

위 예제 CellPhone.java 소스 코드에서도 CellPhone의 생성자가 선언되지 않았지만 컴파일러에 의해 기본 생성자가 만들어지므로 문제없이 실행된다. 만약 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 다음과 같이 작성하면 된다.

```java
자식클래스( 매개변수선언, ㆍㆍㆍ ) {
	super( 매개값, ㆍㆍㆍ );
	ㆍㆍㆍ
}
```

super( 매개값, ㆍㆍㆍ )는 매개값의 타입과 일치하는 부모 생성자를 호출한다. super( 매개값, ㆍㆍㆍ )가 생략되면 컴파일러에 의해  super( )가 자동적으로 추가되기 때문에 부모의 기본 생성자가 존재해야 한다. 부모 클래스에 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 super( 매개값, ㆍㆍㆍ )는 반드시 자식 생성자 첫 줄에 위치해야 한다.



#### 예제 People.java( 부모 클래스 )

```java
public class People {
    public String name;
    public String ssn;

    public People(String name, String ssn) {
        this.name = name;
        this.ssn = ssn;
    }
}
```

People 클래스는 기본 생성자가 없고 name과 ssn을 매개값으로 받아 객체를 생성시키는 생성자만 있다. 그렇기 때문에 People을 상속하는 Student 클래스는 생성자에서 super( name, ssn )으로 People 클래스의 생성자를 호출해야 한다.



#### 예제 Student.java( 자식 클래스 )

```java
public class Student extends People {
    public int studentNo;

    public Student(String name, String ssn, int studentNo) {
      super(name, ssn);				//부모 생성자 호출
      this.studentNo = studentNo;
    }
}
```

Student 클래스의 생성자는 name, ssn, studentNo를 매개값으로 받아서 name과 ssn은 다시 부모 생성자를 호출하기 위해 매개값으로 넘겨준다. 



#### 예제 StudentExample.java( 자식 객체 이용 )

```java
public class StudentExample {
    public static void main(String[] args) {
        Student student = new Student("홍길동", "123456-1234567", 1);

        System.out.println("name : " + student.name);
        System.out.println("ssn : " + student.ssn);
        System.out.println("studentNo : " + student.studentNo);
    }
}
```



#### 결과

```java
name : 홍길동
ssn : 123456-1234567
studentNo : 1
```



## 4. 매소드 재정의

부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수도 있다. 이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야 한다. 이런 경우를 메소드 오버라이딩(Overriding) 이라고 한다.

![Inheritance4](C:\Users\samsung\OneDrive\바탕 화면\Github\img\Inheritance\Inheritance4.png)

### 메소드 재정의(@Override)

메소드를 오버라이딩할 때 주의사항

- 부모의 메소드와 동일한 시그너처( **리턴 타입, 매개 변수 리스트** )를 가져야 한다.
- 접근 제한을 더 강하게 오버라이딩할 수 없다.
- 새로운 예외( Exception )를 throws할 수 없다.

접근 제한을 더 강하게 오바라이딩할 수 없다는 것은 부모 메소드가 public 접근 제한을 가지고 있을 경우 오바라이딩하는 자식 메소드는 default 나 private 접근 제한으로 수정할 수 없다는 뜻이다. 반대는 가능하다. 부모 메소드가 default 접근 제한을 가지면 재정의되는 자식 메소드는 default 또는 public 접근 제한을 가질수 있다.



#### 예제 Calculator.java( 부모 클래스 )

```java
public class Calculator {
    double areaCircle( double r ) {
        System.out.println("Calculator 객체의 areaCircle() 실행");
        return 3.14159 * r * r;
    }
}
```



#### 예제 Computer.java( 자식 클래스 )

```java
public class Computer extends Calculator {
    @Override
    double areaCircle( double r ) { 
        System.out.println("Computer 객체의 areaCircle() 실행");
        return Math.PI * r * r;
    }
}
```



#### 예제 ComputerExample.java( 자식 객체 이용 )

```java
public class ComputerExample {
    public static void main(String[] args) {
        int r = 10;

        Calculator calculator = new Calculator();
        System.out.println("원면적 : " + calculator.areaCircle(r));
        System.out.println();

        Computer computer = new Computer();
        System.out.println("원면적 : " + computer.areaCircle(r));;

    }
}
```



#### 결과

```java
Calculator 객체의 areaCircle() 실행
원면적 : 314.159

Computer 객체의 areaCircle() 실행
원면적 : 314.1592653589793
```



### 부모 메소드 호출(super)

자식 클래스에서 부모 클래스의 메소드를 오버라이딩하게 되면, 부모 클래스의 메소드는 숨겨지고 오버라이딩된 자식 메소드만 사용된다. 그러나 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메소드를 호출할 수 있다. super는 부모 객체를 참조하고 있기 때문에 부모 메소드에 직접 접근할 수 있다.

```java
super.부모메소드( );
```

![Inheritance5](C:\Users\samsung\OneDrive\바탕 화면\Github\img\Inheritance\Inheritance5.png)

#### 예제 Airplane.java( super 변수 )

```java
public class Airplane {
    public void land() {
        System.out.println("착륙합니다.");
    }

    public void fly() {
        System.out.println("일반비행합니다.");
    }

    public void takeOff() {
        System.out.println("이륙합니다.");
    }
}
```



#### 예제 SupersonicAirplane.java( super 변수 )

```java
public class SupersonicAirplane extends Airplane{
    public static final int NORMAL = 1;
    public static final int SUPERSONIC = 2;

    public int flyMode = NORMAL;

    @Override
    public void fly(){
        if(flyMode == SUPERSONIC){
            System.out.println("초음속비행합니다.");
        } else {
            super.fly();
        }
    }
}
```



#### 예제 SupersonicAirplaneExample.java( super 변수 )

```java
public class SupersonicAirplaneExample {
    public static void main(String[] args) {
        SupersonicAirplane sa = new SupersonicAirplane();

        sa.takeOff();
        sa.fly();
        sa.flyMode = SupersonicAirplane.SUPERSONIC;
        sa.fly();
        sa.flyMode = SupersonicAirplane.NORMAL;
        sa.fly();
        sa.land();
    }
}
```



#### 결과

```java
이륙합니다.
일반비행합니다.
초음속비행합니다.
일반비행합니다.
착륙합니다.
```



## 5. final 클래스와 final 메소드

final 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다. final 키워드는 해당 선언이 최종 상태이고, 결코 수정될 수 없음을 뜻한다. final 키워드가 클래스, 필드, 메소드 선언에 사용될 경우 해석이 조금씩 달라지는데, 우리는 이미 6장에서 final 필드에 대해서 살펴보았다. 필드 선언 시에 final이 지정되면 초기값 설정 후, 더 이상 값을 변경할 수 없다는 것을 알았다. 그렇다면 클래스와 메소드에 final이 지정되면 어떤 효과가 날까? 클래스와 메소드 선언 시에 final 키워드가 지정되면 상속과 관련이 있다.



### 상속할 수 없는 final 클래스

클래스를 선언할 때 final 키워드를 class 앞에 붙이게 되면 이 클래스는 상속할 수 없는 클래스가 된다. 즉 final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다는 것이다.

```java
public final class 클래스 {
	ㆍㆍㆍ
}

//final이 선언된 클래스는 아래와 같이 자식 클래스를 만들 수 없다.
public class New클래스 ~~extends 클래스~~ {
	ㆍㆍㆍ
}
```



### 오버라이딩할 수 없는 final 메소드

final 클래스 선언과 마찬가지로 메소드를 선언할 때에도 final을 붙이게 되면 오버라이딩(Overriding)할 수 없는 메소드가 된다.



#### 예제 Car.java( 재정의할 수 없는 final 메소드 )

```java
public class Car {
    //필드
    public int speed;
    
    //메소드
    public void speedUp( ) {
        speed += 1 
	}
    
    //final 메소드
    public final void stop( ) {
        System.out.println("차를 멈춤");
        speed = 0;
    }
}
```





#### 예제 SportsCar.java( 재정의할 수 없는 final 메소드 )

```java
public class SportsCar extends Car {
	@Override
    public void speedUp( ) {
        speed += 10;
    }
    
    //오버라이딩을 할 수 없음.
    @Override
    public void stop( ) {
        System.out.println("스포츠카를 멈춤");
        speed = 0;
    }
    
}
```

