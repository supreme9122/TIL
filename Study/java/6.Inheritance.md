# 상속(Inheritance)

## 1. 상속 개념

상속은 부모가 자식에게 물려주는 행위를 말한다. 자식은 상속을 통해서 무모가 물려준 것을 자연스럽게 이용할 수 있다. 자바에서는 부모 클래스(상위클래스), 자식 클래스(하위 클래스)라고 표현한다.

![Inheritance](https://github.com/supreme9122/TIL/blob/master/img/Inheritance/Inheritance.png)

상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다. field1, field2, method1( ), method2( )를 가지는 클래스를 작성했다고 가정하고 4개를 모두 처음부터 작성하는 것보다는 field1과  method1( )을 가지고 있는 클래스가 있다면 이것을 상속하고 field2, method2( )만 추가 작성하는 것이 효율적이고 개발시간을 절약시킨다.

![Inheritance2](https://github.com/supreme9122/TIL/blob/master/img/Inheritance/Inheritance2.png)

실제로 B 클래스를 객체 생성해서 다음과 같이 사용할 때에는 마치 B가 field1( )과 method1( )을 가지고 있는 것 처럼 보인다.

```java
B b = new B( );
b.field1 = 10;				// A로부터 물려받은 필드와 메소드
b.method( );

b.field2 = "홍길동";			// B가 추가한 필드와 메소드
b.method2( );
```

부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다. 그리고 부모 클래스와 자식클래스가 다른 패키지에 존대한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다. 



## 2. 클래스 상속

현실에서는 부모가 자식을 선택하지만, 프로그램(자바)에서는 자식이 부모를 선택한다. 자식이 부모클래스를 선택할 때에는 다음과 같이 선택한다.

```java
class 자식클래스 extends 부모클래스 {
	//필드
	//생성자
	//메소드
}

 class SportCar extends Car {
     //Car 클래스를 상속해서 SportsCar 클래스를 설계한다.
 }
```

다른 언어와 달리 **자바는 다중 상속을 허용하지 않는다.** 

다음은 핸드폰( Cellphone ) 클래스를 상속해서 DMB폰( DmbCellPhone ) 클래스를 작성한 것이다. 핸드폰이 부모 클래스가 되고, DMB폰이 자식 클래스가 된다.



#### 예제 CellPhone.java( 부모 클래스 )

```java
public class CellPhone {
    //필드
    String model;
    String color;

    //생성자

    //메소드
    void powerOn() {
        System.out.println("전원을 켭니다.");
    }

    void powerOff() {
        System.out.println("전원을 끕니다.");
    }

    void bell() {
        System.out.println("벨이 울립니다.");
    }

    void sendVoice(String message) {
        System.out.println("나 : " + message);
    }

    void receiveVoice(String message) {
        System.out.println("상대방 : " + message);
    }

    void hangUp() {
        System.out.println("전화를 끊습니다.");
    }
}
```



#### 예제 DmbCellPhone.java( 자식 클래스 )

```java
import java.lang.reflect.Method;

public class DmbCellPhone extends CellPhone {
    //필드
    int channel;

    //생성자
    DmbCellPhone(String model, String color, int channel){
        this.model = model;         //CellPhone으로부터 상속받은 필드
        this.color = color;         //CellPhone으로부터 상속받은 필드
        this.channel = channel;
    }

    //메소드
    void turnOnDmb() {
        System.out.println("채널 " + channel + "번 DMB 방송 수신을 시작합니다.");
    }

    void changeChannelDmb(int channel) {
        System.out.println("채널 " + channel + "번 으로 바꿉니다..");
    }

    void turnOffDmb() {
        System.out.println("DMB 방송 수신을 멈춥니다.");
    }
}

```



#### 예제 DmbCellPhoneExample.java( 자식 클래스 사용 )

```java
public class DmbCellPhoneExample {
    public static void main(String[] args) {
        //DmbCellPhone 객체 생성
        DmbCellPhone dmbCellPhone = new DmbCellPhone("자바폰", "검정", 10);

        //CellPhone으로부터 상속받은 필드
        System.out.println("모델 : " + dmbCellPhone.model);
        System.out.println("색상 : " + dmbCellPhone.color);

        //DmbCellPhone의 필드
        System.out.println("채널 : " + dmbCellPhone.channel);

        //CellPhone으로부터 상속받은 메소드 호출
        dmbCellPhone.powerOn();
        dmbCellPhone.bell();
        dmbCellPhone.sendVoice("여보세요");
        dmbCellPhone.receiveVoice("안녕하세요 저는 홍길동인데요");
        dmbCellPhone.sendVoice("그런데요?");
        dmbCellPhone.hangUp();

        //DmbCellPhone의 메소드 호출
        dmbCellPhone.turnOnDmb();
        dmbCellPhone.changeChannelDmb(12);
        dmbCellPhone.turnOffDmb();
    }
}

```

#### 

#### 결과

```java
색상 : 검정
채널 : 10
전원을 켭니다.
벨이 울립니다.
나 : 여보세요
상대방 : 안녕하세요 저는 홍길동인데요
나 : 그런데요?
전화를 끊습니다.
채널 10번 DMB 방송 수신을 시작합니다.
채널 12번 으로 바꿉니다..
DMB 방송 수신을 멈춥니다.
```



## 3. 부모 생성자 호출

자바에서 자식 객체를 생성하려면, 부모 객체가 먼저 생성되어야 한다. 아래 코드는 DmbCellPhone 객체만 생성하는 것처럼 보이지만, 사실은 내부적으로 부모인 CellPhone 객체가 먼저 생성되고, DmbCellPhone 객체가 생성된다.

```java
DmbCellPhone dmbCellPhone = new DmbCellPhone( );
```

이것을 메모리로 표현하면 다음과 같다.

![Inheritance3](https://github.com/supreme9122/TIL/blob/master/img/Inheritance/Inheritance3.png)

자바의 모든 객체는 클래스의 생성자를 호출해야만 생성된다. 그렇다면 부모객체를 생성하기 위해 부모 생성자를 어디서 호출한 것일까? 이것에 대한 비밀은 자식 생성자에 숨어 있다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출 된다. 예를 들어 DmbCellPhone의 생성자가 명시적으로 선언되지 않았다면 **컴파일러는 다음과 같은 기본 생성자를 생성해 낸다.**

```java
public DmbCellPhone() {
	super( );
}
```

super( )는 부모의 기본 생성자를 호출한다.

위 예제 CellPhone.java 소스 코드에서도 CellPhone의 생성자가 선언되지 않았지만 컴파일러에 의해 기본 생성자가 만들어지므로 문제없이 실행된다. 만약 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 다음과 같이 작성하면 된다.

```java
자식클래스( 매개변수선언, ㆍㆍㆍ ) {
	super( 매개값, ㆍㆍㆍ );
	ㆍㆍㆍ
}
```

super( 매개값, ㆍㆍㆍ )는 매개값의 타입과 일치하는 부모 생성자를 호출한다. super( 매개값, ㆍㆍㆍ )가 생략되면 컴파일러에 의해  super( )가 자동적으로 추가되기 때문에 부모의 기본 생성자가 존재해야 한다. 부모 클래스에 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 super( 매개값, ㆍㆍㆍ )는 반드시 자식 생성자 첫 줄에 위치해야 한다.



#### 예제 People.java( 부모 클래스 )

```java
public class People {
    public String name;
    public String ssn;

    public People(String name, String ssn) {
        this.name = name;
        this.ssn = ssn;
    }
}
```

People 클래스는 기본 생성자가 없고 name과 ssn을 매개값으로 받아 객체를 생성시키는 생성자만 있다. 그렇기 때문에 People을 상속하는 Student 클래스는 생성자에서 super( name, ssn )으로 People 클래스의 생성자를 호출해야 한다.



#### 예제 Student.java( 자식 클래스 )

```java
public class Student extends People {
    public int studentNo;

    public Student(String name, String ssn, int studentNo) {
      super(name, ssn);				//부모 생성자 호출
      this.studentNo = studentNo;
    }
}
```

Student 클래스의 생성자는 name, ssn, studentNo를 매개값으로 받아서 name과 ssn은 다시 부모 생성자를 호출하기 위해 매개값으로 넘겨준다. 



#### 예제 StudentExample.java( 자식 객체 이용 )

```java
public class StudentExample {
    public static void main(String[] args) {
        Student student = new Student("홍길동", "123456-1234567", 1);

        System.out.println("name : " + student.name);
        System.out.println("ssn : " + student.ssn);
        System.out.println("studentNo : " + student.studentNo);
    }
}
```



#### 결과

```java
name : 홍길동
ssn : 123456-1234567
studentNo : 1
```



## 4. 매소드 재정의

부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수도 있다. 이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야 한다. 이런 경우를 메소드 오버라이딩(Overriding) 이라고 한다.

![Inheritance4](https://github.com/supreme9122/TIL/blob/master/img/Inheritance/Inheritance4.png)

### 메소드 재정의(@Override)

메소드를 오버라이딩할 때 주의사항

- 부모의 메소드와 동일한 시그너처( **리턴 타입, 매개 변수 리스트** )를 가져야 한다.
- 접근 제한을 더 강하게 오버라이딩할 수 없다.
- 새로운 예외( Exception )를 throws할 수 없다.

접근 제한을 더 강하게 오바라이딩할 수 없다는 것은 부모 메소드가 public 접근 제한을 가지고 있을 경우 오바라이딩하는 자식 메소드는 default 나 private 접근 제한으로 수정할 수 없다는 뜻이다. 반대는 가능하다. 부모 메소드가 default 접근 제한을 가지면 재정의되는 자식 메소드는 default 또는 public 접근 제한을 가질수 있다.



#### 예제 Calculator.java( 부모 클래스 )

```java
public class Calculator {
    double areaCircle( double r ) {
        System.out.println("Calculator 객체의 areaCircle() 실행");
        return 3.14159 * r * r;
    }
}
```



#### 예제 Computer.java( 자식 클래스 )

```java
public class Computer extends Calculator {
    @Override
    double areaCircle( double r ) { 
        System.out.println("Computer 객체의 areaCircle() 실행");
        return Math.PI * r * r;
    }
}
```



#### 예제 ComputerExample.java( 자식 객체 이용 )

```java
public class ComputerExample {
    public static void main(String[] args) {
        int r = 10;

        Calculator calculator = new Calculator();
        System.out.println("원면적 : " + calculator.areaCircle(r));
        System.out.println();

        Computer computer = new Computer();
        System.out.println("원면적 : " + computer.areaCircle(r));;

    }
}
```



#### 결과

```java
Calculator 객체의 areaCircle() 실행
원면적 : 314.159

Computer 객체의 areaCircle() 실행
원면적 : 314.1592653589793
```



### 부모 메소드 호출(super)

자식 클래스에서 부모 클래스의 메소드를 오버라이딩하게 되면, 부모 클래스의 메소드는 숨겨지고 오버라이딩된 자식 메소드만 사용된다. 그러나 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메소드를 호출할 수 있다. super는 부모 객체를 참조하고 있기 때문에 부모 메소드에 직접 접근할 수 있다.

```java
super.부모메소드( );
```

![Inheritance5](https://github.com/supreme9122/TIL/blob/master/img/Inheritance/Inheritance5.png)

#### 예제 Airplane.java( super 변수 )

```java
public class Airplane {
    public void land() {
        System.out.println("착륙합니다.");
    }

    public void fly() {
        System.out.println("일반비행합니다.");
    }

    public void takeOff() {
        System.out.println("이륙합니다.");
    }
}
```



#### 예제 SupersonicAirplane.java( super 변수 )

```java
public class SupersonicAirplane extends Airplane{
    public static final int NORMAL = 1;
    public static final int SUPERSONIC = 2;

    public int flyMode = NORMAL;

    @Override
    public void fly(){
        if(flyMode == SUPERSONIC){
            System.out.println("초음속비행합니다.");
        } else {
            super.fly();
        }
    }
}
```



#### 예제 SupersonicAirplaneExample.java( super 변수 )

```java
public class SupersonicAirplaneExample {
    public static void main(String[] args) {
        SupersonicAirplane sa = new SupersonicAirplane();

        sa.takeOff();
        sa.fly();
        sa.flyMode = SupersonicAirplane.SUPERSONIC;
        sa.fly();
        sa.flyMode = SupersonicAirplane.NORMAL;
        sa.fly();
        sa.land();
    }
}
```



#### 결과

```java
이륙합니다.
일반비행합니다.
초음속비행합니다.
일반비행합니다.
착륙합니다.
```



## 5. final 클래스와 final 메소드

final 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다. final 키워드는 해당 선언이 최종 상태이고, 결코 수정될 수 없음을 뜻한다. final 키워드가 클래스, 필드, 메소드 선언에 사용될 경우 해석이 조금씩 달라지는데, 우리는 이미 6장에서 final 필드에 대해서 살펴보았다. 필드 선언 시에 final이 지정되면 초기값 설정 후, 더 이상 값을 변경할 수 없다는 것을 알았다. 그렇다면 클래스와 메소드에 final이 지정되면 어떤 효과가 날까? 클래스와 메소드 선언 시에 final 키워드가 지정되면 상속과 관련이 있다.



### 상속할 수 없는 final 클래스

클래스를 선언할 때 final 키워드를 class 앞에 붙이게 되면 이 클래스는 상속할 수 없는 클래스가 된다. 즉 final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다는 것이다.

```java
public final class 클래스 {
	ㆍㆍㆍ
}

//final이 선언된 클래스는 아래와 같이 자식 클래스를 만들 수 없다.
public class New클래스 ~~extends 클래스~~ {
	ㆍㆍㆍ
}
```



### 오버라이딩할 수 없는 final 메소드

final 클래스 선언과 마찬가지로 메소드를 선언할 때에도 final을 붙이게 되면 오버라이딩(Overriding)할 수 없는 메소드가 된다.



#### 예제 Car.java( 재정의할 수 없는 final 메소드 )

```java
public class Car {
    //필드
    public int speed;
    
    //메소드
    public void speedUp( ) {
        speed += 1 
	}
    
    //final 메소드
    public final void stop( ) {
        System.out.println("차를 멈춤");
        speed = 0;
    }
}
```





#### 예제 SportsCar.java( 재정의할 수 없는 final 메소드 )

```java
public class SportsCar extends Car {
	@Override
    public void speedUp( ) {
        speed += 10;
    }
    
    //오버라이딩을 할 수 없음.
    @Override
    public void stop( ) {
        System.out.println("스포츠카를 멈춤");
        speed = 0;
    }
    
}
```



## 6. protected 접근 제한자

접근 제한자는 public, protected, default, private와 같이 네 가지 종류가 있다. 이 중에서 protected는 상속과 관련이 있기 때문에 설명을 미루어 왔는데, 이제 protected가 어떤 역할을 하는지 알아보자.

![image-20201228222019364](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20201228222019364.png)

| 접근 제한 | 적용할 내용                  | 접근할 수 없는 클래스                          |
| --------- | ---------------------------- | ---------------------------------------------- |
| public    | 클래스, 필드, 생성자, 메소드 | 없음                                           |
| protected | 필드, 생성자, 메소드         | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default   | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스                    |
| private   | 필드, 생성자, 메소드         | 모든 외부 클래스                               |



protected는 public과 default 접근 제한의 중간쯤에 해당한다. 같은 패키지에서는 default와 같이 접근 제한이 없지만 다른 패키지에서는 자식 클래스만 접근을 허용한다.

![image-20201228223028654](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20201228223028654.png)

protected는 필드와 생성자, 메소드 선언에 사용될 수 있다. 다음 A클래스를 보면 protected로 선언된 필드, 생성자, 메소드가 있다.



#### 예제 A.java ( 접근 제한자 )

```java
package package1;

public class A {
	protected String field;
	
	protected A( ) {
	}
	
	protected void method( ) {
	}
}
```



다음 B 클랫흐는 A 클래스와 동일한 패키지에 있다. default 접근 제한과 마찬가지로 B 클래스의 생성자와 메소드에서는 A 클래스의 protected 필드, 생성자, 메소드에 얼마든지 접근이 가능하다.



#### 예제 B.java ( protected 접근 제한자 테스트 )

```java
package package1;

public class B {
	public void method ( ) {
		A a = new A( );		// O
		a.field = "value";	// O
		a.method( );		// O
	}
}
```



다음 C 클래스는 A 클래스와 다른 패키지에 있다.  default 접근 제한과 마찬가지로 C 클래스의 생성자와 메소드에서는 A 클래스의 protected 필드, 생성자, 메소드에 접근할 수 없다.



#### C.java ( protected 접근 제한자 테스트 )

```java
package package2;
import package1.A;

public class C {
	protected void method ( ) {
		A a = new A( );		// X
		a.field = "value";	// X
		a.method( );		// X
	}
}
```



다음 D 클래스는 A 클래스와 다른 패키지에 있다. C 클래스와는 달리 D는 A의 자식 클래스이다. 그렇기 때문에 A 클래스의 protected 필드, 생성자, 메소드에 접근이 가능하다. 단 new 연산자를 사용해서 생성자를 직접 호출할 수는 없고, 자식 생성자에서 super( )로 A 생성자를 호출할 수 있다.

```java
package package1;
import package1.A;

public class D extends A {
	protected void method ( ) {
		super( );				// O
		this.field = "value";	// O
		this.method( );			// O
	}
}
```



## 7. 타입 변환과 다형성

다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다. 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용한다. 즉 부모 타입에 모든 자식객체가 대입될 수 있다. 이것을 이용하면 객체는 부품화가 가능하다. 예를 들어 자동차를 설계할 때 타이어 클래스 타입을 적용했다면 이 클래스를 상속한 실제 타이어들은 어떤 것이든 상관없이 장착(대입)이 가능하다.

![image-20201228225122549](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20201228225122549.png)

위 그림을 코드로 표현하면 다음과 같다.

```java
public class Car {
	Tire t1 = new HankookTire( );
	Tire t2 = new KumhoTire( );

    //  Tire          t1  =  new HankookTire( );
    //타이어 타입 필드          자식 타입 객체 타입
}
```

타입 변환이란 데이터 타입을 다른 데이터 타입으로 변환하는 행위를 말한다. 기본 타입의 변환에 대해서는 이미 2장에서 학습한 바 있다. 클래스 타입도 마찬가지로 타입 변환이 있다. 클래스 타입의 변환은 상속 관계에 있는 클래스 사이에서 발생한다. 자식 타입은 부모 타입으로 자동 타입 변환이 가능하다. 위 그림에서 HankookTire 와 KumhoTire는 Tire를 상속했기 때문에 Tire 변수에 대입할 수 있다.



### 자동 타입 변환 ( Promotion )

자동 타입 변환 ( Promotion )은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다. 자동 타입 변환은 다음과 같은 조건에서 일어난다.

```java
부모클래스 변수 = 자식클래스타입;
```

자동 타입 변환의 개념은 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급할 수 있다는 것이다. 예를 들어 고양이는 동물의 특징과 기능을 상속받았다. 그래서 "고양이는 동물이다"가 성립한다. Animal과 Cat 클래스가 다음과 같이 상속 관계에 있다고 보자.

![image-20201229212448269](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20201229212448269.png)

Cat 클래스로부터 Cat 객체를 생성하고 이것을 Animal 변수에 대입하면 자동 타입 변환이 일어난다.

```java
Cat cat = new Cat( );
Animal animal = cat;		//Animal animal = new Cat( ); 도 가능
```

위 코드로 생성되는 메모리 상태를 그림으로 묘사하면 다음과 같다. cat과 animal 변수는 타입만 다를 뿐, 동일한 Cat 객체를 참조한다.

![image-20201229213440775](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20201229213440775.png)

위 그림에서 aniaml 변수가 Aniaml 타입이므로 당연히 부모인 Animal 객체를 참조하는 것이 맞지 않느냐라고 생각할 수도 있지만, 사실은 그렇지 않다. 다음과 같이 cat과 aniaml 변수를 == 연산해보면 true가 나오는데, 참조 변수의 == .연산은 참조 주소값이 같을 경우 true를 산출하므로 두 변수가 동일한 객체를 참조하고 있다는 뜻이다.

```java
cat == animal		//true
```

바로 위의 부모가 아니더라도 상속 계층에서 상위 타입이라면 자동 타입 변환이 일어날 수 있다. 다음 그림을 보면서 이해해보자.

![image-20201229220914138](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20201229220914138.png)

D 객체는  B와 A 타입으로 자동 타입 변환이 될 수 있고, E 객체는 C와  A 타입으로 자동 타입 변환이 될 수 있다. 그러나 D 객체는 C 타입으로 변환될 수 없고, 마찬가지로 E 객체는 B 타입으로 변환될 수 없다. 이유는 상속 관계가 아니기 때문이다.



#### 예제 PromotionExample.java ( 자동 타입 변환 )

```java
class A { }

class B extends A { }
class C extends A { }
class D extends B { }
class E extends C { }

public class PromotionExample {
	public static void main(String[] args){
		B b = new B( );
		C c = new C( );
		D d = new D( );
		E e = new E( );
		
		A a1 = b;
		A a2 = c;
		A a3 = d;
		A a4 = e;
		
		B b1 = d;
		C c1 = e;
		
		//컴파일 에러( 상속 관계에 있지 않음)
		//B b3 = e;
		//C c2 = d; 
	}
}
```



부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다. 비록 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로만 한정된다. 그러나 예외가 있는데, 메소드가 자식 클래스에서 오버라이딩되었다면 자식 클래스의 메소드가 대신 호출된다. 이것은 다형성(Polymorphism)과 관련이 있기 때문에 매우 중요한 성질이므로 잘 알아두어야 한다. 다음 그림을 보고 이해하자.

![image-20201229222433082](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20201229222433082.png)

Child 객체는 method3( ) 메소드를 가지고 있지만, Parent 타입으로 변환된 이후에는 method3( )을 호출할 수 없다. 그러나 method2( ) 메소드는 부모와 자식 모두에게 있다. 그러나 method2( ) 메소드는 부모와 자식 모두에게 있다. 이렇게 오버라이딩된 메소드는 타입 변환 이후에도 자식 메소드가 호출된다.



#### 예제 Parent.java ( 자동 타입 변환 후의 멤버 접근 )

```java
public class Parent {
    public void method1( ) {
        System.out.println("Praent-method1()");
    }

    public void method2( ) {
        System.out.println("Praent-method2()");
    }
}
```



#### 예제 Child.java ( 자동 타입 변환 후의 멤버 접근 )

```java
public class Child extends Parent {
    @Override
    public void method2( ) {
        System.err.println("Child-method2()");
    }
    
}
```



#### 예제 ChildExample.java ( 자동 타입 변환 후의 멤버 접근 )

```java
public class ChildExample {
    public static void main(String[] args) {
        Child child = new Child();

        Parent parent = child;      //자동 타입 변환
        parent.method1();
        parent.method2();           //재정의된 메소드가 호출됨.
        //parent.method3();         //호출 불가능
    }
}
```



#### 결과

```java
Praent-method1()
Child-method2()
```



### 필드의 다형성

왜 자동 타입 변환이 필요할까? 그냥 자식 타입으로 사용하면 될 것을 부모 타입으로 변환해서 사용하는 이유가 무엇일까? 그것은 다형성을 구현하는 기술적 방법 때문이다. 다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질을 말한다. 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현하는데, 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라질 수 있다. 이것이 필드의 다형성이다. 자동차를 구성하는 부품은 언제든지 교체할 수 있다. 부품은 고장 날 수도 있고, 보다 더 성능이 좋은 부품으로 교체되기도 한다. 객체 지향 프로그램에서도 마찬가지이다. 프로그램은 수많은 객체들이 서로 연결되고 각자의 역할을 하게 되는데, 기 객체들은 다른 객체로 교체될 수 있어야 한다. 예를 들어 자동차 클래스에 포함된 타이어 클래스를 생각해보자. 자동차 클래스를 처음 설계할 때사용한 타이어 객체는 언제든지 성능이 좋은 다른 타이어 객체로 교체할 수 있어야 한다. 새로 교체되는 타이어 객체는 기존 타이어와 사용 방법은 동일하지만 실행 결과는 더 우수하게 나와야 할 것이다. 이것을 프로그램으로 구현하기 위해서는 상속과 오버라이딩, 그리고 타입 변환을 이용하는 것이다. 부모 클래스를 상속하는 자식 클래스는 부모가 가지고 있는 필드와 메소드를 가지고 있으니 사용 방법이 동일할 것이고, 자식 클래스는 부모의 메소드를 오버라이딩(재정의)해서 메소드의 실행 내용을 변경함으로써 더 우수한 실행 결과가 나오게 할 수 있다. 그리고 자식 타입을 부모 타입으로 변환할 수 있다. 필드의 다형성을 코드로 이해해보자.

```java
class Car {
	//필드
	Tire frontLeftTire = new Tire( );
	Tire frontRightTire = new Tire( );
	Tire backLeftTire = new Tire( );    
	Tire backRightTire = new Tire( );
	
	//메소드
	void run( ) {
	
	}
}
```

Car 클래스는 4개의 Tire 필드를 가지고 잇다. Car 클래스로부터 Car 객체를 생성하면 4개의 Tire 필드에 각각 하나씩 Tire 객체가 들어가게 된다. 그런데, frontRightTire와 backLeftTire를 HankookTire와 KumhoTire로 교체할 필요성이 생겼다. 이러한 경우 다음과 같은 코드를 사용해서 교체할 수 있다.

```java
Car myCar = new Car( );
myCar.frontRightTire = new HankookTire( );
myCar.backLeftTire = new KumhoTire( );
myCar.run( );
```

Tire 클래스 타입인 frontRightTire와 backLeftTire는 원래 Tire 객체가 저장되어야 하지만, Tire의 자식 객체가 저장되어도 문제가 없다. 왜냐하면 자식 타입은 부모 타입으로 자동 타입 변환이 되기 때문이다. frontRightTire와 backLeftTire에 Tire 자식 객체가 저장되어도 Car 객체는 Tire 클래스에 선언된 필드와 메소드만 사용하므로 전혀 문제가 되지 않는다. HankookTire와 KumhoTire는 부모인 Tire의 필드와 메소들 가지고 있기 때문이다. Car 객체에 run( ) 메소드가 있고, run( ) 메소드는 각 Tire 객체의 roll( ) 메소드를 다음과 같이 호출한다고 가정해보자.

```java
void run( ) {
	frontLeftTire.roll( );
	frontRightTire.roll( );
	backLeftTire.roll( );
	backRightTire.roll( );
}
```

frontRightTire와 backLeftTire를 교체하기 전에는 Tire 객체의 roll( ) 메소드가 호출되지만, HankookTire 와 KumhoTire로 교체되면 HankookTire와 KumhoTire가 roll() 메소드를 재정의하고 있으므로 교체 이후에는 HankookTire와 KumhoTire의 roll( ) 메소드가 호출된다. 이 성질은 이미 7.4 메소드의 재정의에서 살펴보았다. 이와 같이 자동 타입 변환을 이용해서 Tire 필드값을 교체함으로써 Car의 run( ) 메소드 수정 없이도 다양한 roll( ) 메소드의 실행 결과를 얻게 된다. 이것이 바로 필드의 다형성이다.

예제를 작성해보면서 지금까지 설명했던 내용을 눈으로 확인해보자. 먼저 Tire 클래스를 보자. Tire 클래스의 필드에는 최대 회전수(maxRotation), 누적 회전수(accumulatedRotation), 타이어의 위치(location)가 있다. 최대 회전수는 타이어의 수명으로, 최대 회전수만큼 도달하면 타이어가 펑크가 난다고 가정했다. 누적 회전수는 타이어가 1번 회전할 때마다 1씩 증가되는 필드로, 누적 회전수가 최대 회전수가 되면 타이어는 펑크가 난다. 타이어의 위치는 앞왼쪽, 앞오른쪽, 뒤 왼쪽, 뒤 오른쪽으로 구분하는 필드이다. Tire 클래스의 생성자는 타이어의 위치와 최대 회전수를 매개값으로 받아 각각의 필드에 저장한다. roll( ) 메소드는 타이어를 1회전시키는 메소드로 1번 실행할 때마다 누적 회전수를 1씩 증가시킨다. 그런 다음 누적 회전수가 최대 회전수보다 작을 때에는 남은 회전수를 출력하고, 최대 회전수가 되면 펑크를 출력 시킨다. roll( ) 메소드의 리턴 타입은 boolean인데, 정상 회전하면 true, 펑크 나면 false를 리턴한다.



#### 예제 Tire.java ( 타이어 클래스 )

```java
public class Tire {
    //필드
    public int maxRotaion;              //최대 회전수(타이어 생명)
    public int accumulatedRotation;     //누적 회전수
    public String location;             //타이어의 위치

    //생성자
    public boolean roll( ) {
        ++accumulatedRotation;      //누적 회전수 1증가
        if(accumulatedRotation<maxRotaion) {
            System.out.println(location + "Tire의 수명 : " +            //정상 회전(누적<최대)일 경우 실행
                (maxRotaion-accumulatedRotation) + "회");
            return true;
        } else {
            System.out.println("*** " + location + "Tire 펑크 ***");    //펑크(누적=최대)일 경우 실행
            return false;
        }
     }
}
```

이번에는 Car 클래스를 보자. Car 클래스의 필드는 네 개의 타이어가 있다. Tire 객체를 생성할 때 타이어의 위치와 최대 회전수를 생성자의 매개값으로 지정했다. frontLeftTire 필드일 경우, 최대 회전수를 6으로 주었기 때문이 6회전 시 타이어가 펑크 나도록 했다. run( ) 메소드는 네 개의 타이어를 한 번씩 1회전시키는 메소드이다. 각각의 Trie 객체의 roll( ) 메소드를 호출해서 리턴값이 false가 되면(펑크 나면) stop( ) 메소드를 호출하고 해당 위치의 타이어 번호를 리턴한다. 타이어 번호는 타이어를 교체할 때 어떤 위치의 타이어인지 알 수 있도록 하기 위해 사용된다. stop( ) 메소드는 타이어가 펑크 날 때 자동차를 멈추는 메소드이다.

#### 예제 Car.java ( Tire를 붛품으로 가지는 클래스 )

```java
import jdk.nashorn.internal.ir.ReturnNode;

public class Car{
    //필드
    Tire frontLeftTire = new Tire("앞왼쪽", 6);
    Tire frontRightTire = new Tire("앞오른쪽", 2);
    Tire backLeftTire = new Tire("뒤왼쪽", 3);
    Tire backRightTire = new Tire("뒤오른쪽", 4);

    //생성자

    //메소드
    int run( ){
        System.out.println("[자동차가 달립니다.]");
        //모든 타이어를 1회 회전시키기 위해 각 Tire 객체의 roll( ) 메소드를 호출한다.
        //false를 리턴하는 roll( )이 있을 경우 stop( ) 메소드를 호출하고 해당 타이어 번호를 리턴한다.
        if(frontLeftTire.roll()==false) { stop(); return 1; }
        if(frontRightTire.roll()==false) { stop(); return 2; }
        if(backLeftTire.roll()==false) { stop(); return 3; }
        if(backRightTire.roll()==false) { stop(); return 4; }
        return 0;
    }

    //펑크 났을 때 실행
    void stop( ){
        System.out.println("[자동차가 멈춥니다.]");
    }
}
```

이번에는 HankookTire와 KumhoTire 클래스를 보자. 이 두 클래스는 Tire 클래스를 상속받는다. 생성자는 타이어의 위치, 최대 회전수를 매개값으로 받아서 부모인 Tire 클래스의 생성자를 호출할 때 넘겨주었다. roll( ) 메소드는 오버라이딩되었는데, 정상 회전과 펑크 났을 때 출력하는 내용이 Tire 클래스의 roll( ) 메소드와 다르다. 

#### 예제 HankookTire.java ( Tire의 자식 클래스 )

```java
public class HankookTire extends Tire {
    //필드
    //생성자
    public HankookTire(String location, int maxRotation) {
        super(location, maxRotation);
    }

    //메소드
    @Override
    public boolean roll( ) {
        ++accumulatedRotation;      
        if(accumulatedRotation<maxRotaion) {
            System.out.println(location + "HankookTire의 수명 : " +           
                (maxRotaion-accumulatedRotation) + "회");
            return true;
        } else {
            System.out.println("*** " + location + "HankookTire 펑크 ***");
            return false;
        }                                                                      
    }
}
```

#### 예제 KumhoTire.java ( Tire의 자식 클래스 )

```java
public class KumhoTire extends Tire {
    //필드
    //생성자
    public KumhoTire(String location, int maxRotation) {
        super(location, maxRotation);
    }

    //메소드
    @Override
    public boolean roll( ) {
        ++accumulatedRotation;      
        if(accumulatedRotation<maxRotaion) {
            System.out.println(location + "KumhoTire의 수명 : " +           
                (maxRotaion-accumulatedRotation) + "회");
            return true;
        } else {
            System.out.println("*** " + location + "KumhoTire 펑크 ***");
            return false;
        }                                                                      
    }
}
```

마지막으로 CarExample 클래스를 보자. CarExample 클래스는 지금까지 작성한 Tire, Car, HankookTire, KumhoTire 클래스를 이요하는 실행 클래스이다.



#### 예제 CarExample.java  ( 실행 클래스 )

```java
public class CarExample {
    public static void main(String[] args) {
        Car car = new Car( );

        for(int i = 1; i <= 5; i++) {
            int problemLocation = car.run();
        

            switch(problemLocation) {
                case 1:
                    System.out.println("앞왼쪽 HankookTire로 교체");
                    car.frontLeftTire =  new HankookTire("앞왼쪽", 15);
                    break;
                case 2:
                    System.out.println("앞오른쪽 KumhoTire로 교체");
                    car.frontRightTire = new KumhoTire("앞오른쪽", 13);
                    break;
                case 3:
                    System.out.println("뒤왼쪽 HankookTire로 교체");
                    car.frontRightTire = new KumhoTire("뒤왼쪽", 14);
                    break;
                case 4:
                    System.out.println("뒤오른쪽 KumhoTire로 교체");
                    car.frontRightTire = new KumhoTire("뒤오른쪽", 17);
                    break;
            }
            System.out.println("-----------------------------");
        }
    }
}
```

Car 객체를 생성한다. forn문은 5번을 반복 루핑하도록 초기값과 조건식을 주었다. Car 객체의 run( ) 메소드를 실행하도록 했다. run( )  메소드의 리턴값은 펑크 난 타이어의 번호인데, 정상( 0 ), 앞왼쪽( 1 ), 앞오른쪽( 2 ), 뒤왼쪽( 3 ), 뒤 오른쪽( 4 )인 값이다. switch문은 problemLocation 변수의 값에 따라 Car 객체의 해당 타이어를 새 HankookTire와 KumhoTire 객체로 교체한다. 주목할 코든 Car 객체의 Tire 필드에 HankookTire와 KumhoTire 객체를 대입하고 있다. 즉 자동 타입 변환이 되고 있다. 교체된 이후부터는 Car 객체의 run( ) 메소드가 호출될 때 HankookTire 와 KumhoTire에서 재정의(오바라이딩) 된 roll( ) 메소드가 실행된다.

#### 결과

```java
[자동차가 달립니다.]
앞왼쪽Tire의 수명 : 5회
앞오른쪽Tire의 수명 : 1회
뒤왼쪽Tire의 수명 : 2회
뒤오른쪽Tire의 수명 : 3회
-----------------------------
[자동차가 달립니다.]
앞왼쪽Tire의 수명 : 4회
*** 앞오른쪽Tire 펑크 ***
[자동차가 멈춥니다.]
앞오른쪽 KumhoTire로 교체
-----------------------------
[자동차가 달립니다.]
앞왼쪽Tire의 수명 : 3회
앞오른쪽KumhoTire의 수명 : 12회
뒤왼쪽Tire의 수명 : 1회
뒤오른쪽Tire의 수명 : 2회
-----------------------------
[자동차가 달립니다.]
앞왼쪽Tire의 수명 : 2회
앞오른쪽KumhoTire의 수명 : 11회
*** 뒤왼쪽Tire 펑크 ***
[자동차가 멈춥니다.]
뒤왼쪽 HankookTire로 교체
-----------------------------
[자동차가 달립니다.]
앞왼쪽Tire의 수명 : 1회
뒤왼쪽KumhoTire의 수명 : 13회
*** 뒤왼쪽Tire 펑크 ***
[자동차가 멈춥니다.]
뒤왼쪽 HankookTire로 교체
-----------------------------
```

다음 결과를 보면 앞오른쪽 타이어의 최대 회전수가 2이므로 2번째 roll( ) 메소드 호출 시 펑크가 나서 자동차는 멈춘다. 동적으로 KumhoTire로 교체 후, 다시 정상적으로 프로그램은 계속 실행된다. 교체 후 출력되는 내용을 보면 앞오른쪽 타이어의 종류가 KumhoTire인 것을 알 수 있다.



### 하나의 배열로 객체 관리

이전 예제에서 Car 클래스에 4개의 타이어 객체를 4개의 필드로 각각 저장했다. 우리는 동일한 타입의 값들은 배열로 관리하는 것이 유리하다는 것을 알고 있다. 그렇다면 타이어 객체들도 타이어 배열로 관리하는 것이 코드를 깔끔하게 만들어줄 것이다.

```java
class Car {
	Tire frontLeftTire = new Tire("앞왼쪽", 6);
	Tire frontRightTire = new Tire("앞오른쪽", 2);
	Tire backLeftTire = new Tire("뒤왼쪽", 3);
	Tire backRightTire = new Tire("뒤오른쪽", 4);
}

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

class Car {
	Tire[] tires = 
		new Tire("앞왼쪽", 6);
		new Tire("앞오른쪽", 2);
		new Tire("뒤왼쪽", 3);
		new Tire("뒤오른쪽", 4);
}
```

frontLeftTire는 tires[0], frontRightTire는 tires[1] ㆍㆍㆍㆍ와 같이 인덱스로 표현되므로 대입이나 제어문에서 활용하기 매우 쉽다. 예를 들어 인덱스 1을 이용해서 앞오른쪽 타이어를 KumhoTire로 교체하기 위해 다음과 같이 작성할 수 있다.

```java
tires[1] = new KumhoTire("앞오른쪽", 13);
```

tires 배열의 각 항목은 Tire 타입이므로 자식 객체인 KumhoTire를 대입하면 자동 타입 변환이 발생하기 때문에 아무런 문제가 없다. 배열의 타입은 Tire이지만 실제 저장 항목이 Tire의 자식 객체라면 모두 가능하다. 상속 관계에 있는 객체들을 배열로 관리하면 제어문에서 가장 많이 혜택을 본다. 전체 타이어의 roll( ) 메소드를 호출하는 Car 클래스의 run( ) 메소드는 다음과 같이 for문으로 작성할 수 있다.

```java
int run( ){
	System.out.println("[자동차가 달립니다.]");
	for(int i = 0; i < tires.length; i++){
		if(tires[i].roll( ) == false) {
			stop();
			return (i+1);
		}
	}
	return 0;
}
```

다음은 이전 예제에서 작성한 Car 클래스의 타이어 필드를 배열로 수정한 전체 내용을 보여준다.



#### 예제 Car.java ( Tire를 부품으로 가지는 클래스 )

```java
public class Car{
    //필드
    Tire[] tires = {
        new Tire("앞왼쪽", 6),
        new Tire("앞오른쪽", 2),
        new Tire("뒤왼쪽", 3),
        new Tire("뒤오른쪽", 4)
    };

    //메소드
    int run( ){
        System.out.println("[자동차가 달립니다.]");
        for(int i = 0; i < tires.length; i++) {
            if(tires[i].roll() == false){
                stop();
                return (i+1);
            }
        }
        return 0;
    }

    //펑크 났을 때 실행
    void stop( ){
        System.out.println("[자동차가 멈춥니다.]");
    }
}
```

Car 클래스를 이용하는 CarExample 클래스도 다음과 같이 간결하게 수정할 수 있다.



#### 예제 CarExample.java (실행 클래스 )

```java
public class CarExample {
    public static void main(String[] args) {
        Car car = new Car( );

        for(int i = 1; i <= 15; i++) {
            int problemLocation = car.run();
            if(problemLocation != 0){
                System.out.println(car.tires[problemLocation-1].location+" HankookTire로 교체");
                car.tires[problemLocation-1] =
                    new HankookTire(car.tires[problemLocation-1].location, 15);
            }
            System.out.println("-----------------------------");
        }
    }
}
```



### 매개 변수의 다형성

자동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 메소드를 호출할 때 많이 발생한다. 메소드를 호출할 때에는 매개 변수의 타입과 동일한 매개값을 지정하는 것이 정석이지만, 매개값을 다양화하기 위해 매개 변수에 자식 타입 객체를 지정할 수도 있다. 예를 들어 다음과 같이 Driver라는 클래스가 있다. Driver 클래스에는 drive( ) 메소드가 정의되어 있는데 Vehicle 타입의 매개 변수가 선언되어 있다.

```java
class Driver{
	void drive(Vehicle vehicle) {
		vehicle.run();
	}
}
```

drive 메소드를 정상적으로 출한다면 다음과 같을 것이다.

```java
Driver driver = new Driver( );
Vehicle vehicle = new Vehicle( );
driver.drive(vehicle);
```

 만약 Vehicle의 자식 클래스인 Bus 객체를 drive( ) 메소드의 매개값으로 넘겨준다면 어떻게 될까?

![image-20210104204909257](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20210104204909257.png)

drive( ) 메소드는 Vehicle 타입을 매개 변수로 선언했지만, Vehicle을 상속받는 Bus 객체가 매개값으로 사용되면 자동 타입 변환이 발생한다.

우리는 여기서 매우 중요한 것을 하나 알게 되었다. 매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다는 것이다. 매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 잇다.(매개 변수의 다형성) 자식 객체가 부모의 메소드를 재정의(오버라이딩) 했다면 메소드 내부에서 오버라이딩된 메소드를 호출함으로써 메소드의 실행 결과는 다양해진다.



```java
void drvice(Vehicle vehicle) {
	vehicle.run( );				//자식 객체가 재정의한 run( ) 메소드 실행
}
```



예제를 작성해보면서 지금까지 설명했던 내용을 눈으로 확인해보자. 우선 Vehicle 클래스가 다음과 같이 작성되었다고 가정해보자.



#### 예제 Vehicle.java 부모 클래스

```java
public class Vehicle {
    public void run() {
        System.out.println("차량이 달립니다.");
    }
}
```



#### 예제 Driver.java ( Vehicle을 이용하는 클래스 )

```java
public class Driver {
    public void drvie(Vehicle vehicle){
        vehicle.run();
    }
}
```

Driver 클래스인데, drive( ) 메소드에서 Vehicle 타입의 매개값을 받아서 run( ) 메소드를 호출한다.



#### 예제 Bus.java ( 자식 클래스 )

```java
public class Bus extends Vehicle {
    @Override
    public void run(){
        System.out.println("버스가 달립니다.");
    }
}
```



#### 예제 Taxi.java ( 자식 클래스 )

```java
public class Taxi extends Vehicle {
    @Override
    public void run() {
        System.out.println("택시가 달립니다.");
    }
}
```

다음은 Bus 클래스와 Taxi 클래스인데, Vehicle 클래스를 상속받아 run( ) 메소드를 오버라이딩 하고 있다.



#### 얘재 DrvierExample.java ( 실행 클래스 )

```java
public class DriverExample {
    public static void main(String[] args) {
        Driver drvier = new Driver();
        Vehicle vehicle = new Vehicle();

        Bus bus = new Bus();
        Taxi taxi = new Taxi();

        drvier.drvie(vehicle);
        drvier.drvie(bus);
        drvier.drvie(taxi);
    }
}
```



#### 결과

```java
차량이 달립니다.
버스가 달립니다.
택시가 달립니다.
```



먼저 Driver 객체와 Vehicle, Bus, Taxi 객체를 생성하고 drvie( ) 메소도를 호출할 때 Vehicle 객체와 Bus 객체와 Taxi객체를 제공했다. 결과를 보면 각 객체의 run( ) 메소드 실행 결과를 확인할 수있고, 이와 같이 매개값의 자동 타입 변환과 메소드 오버라이딩을 이용해서 매개변수의 다형성을 구현할 수 있다.



### 강제 타입 변환( Casting )

강제 타입 변환(Casting)은 부모 타입을 자식 타입으로 변환하는 것을 말한다. 그렇다고 해서 모든 부모 타입을 자식 클래스 타입으로 강제 변환할 수 있는 것은 아니다. 자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변활할 때 강제 타입 변환을 사용할 수 있다.

```java
자식클래스 변수 = ( 자식클래스 ) 부모클래스타입;
							//자식 타입이 부모 타입으로 변환된 상태
```

자식 타입이 부모 타입으로 자동 변환하면, 부모 타입에 선언된 필드와 메소드만 사용 가능하다는 제약 사항이 따른다. 만약 자식 타입에서 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환을 해서 다시 자식 타입 변환으로 변환한 다음 자식 타입의 필드와 메소드를 사용하면 된다.

![image-20210104212114116](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20210104212114116.png)

field2 필드와  method3( )  메소드는 Child 타입에만 선언되어 있으므로 Parent 타입으로 자동 타입 변환하면 사용할 수 없다. field2 필드와 method3( ) 메소드를 사용하고 싶다면 다시 Child 타입으로 강제 타입 변환을 해야 한다.



#### 예제 Parent.java ( 부모 클래스 )

```java
public class Parent {
	public String field1;
	
	public void method1( ) {
		System.out.println("Parent-method1( )");
	}
	
	public void method2( ) {
		System.out.println("Parent-method2( )");
	}
}
```



#### 예제 Child.java ( 자식 클래스 )

```java
public class Child extends Parent {
	public String field2;
	public void method3( ) {
		System.out.println("Child-method3( )");
	}
}
```



#### 예제 ChildExample.java ( 강제 타입 변환 (캐스팅) )

```java
public class ChildExample {
	public static void main(String[] agrs) {
		Parent parent = new Child( );		//자동 타입 변환
		parent.field1 = "data1";
		parent.method1( );
		parent.method2( );
		
		/*
		parent.field2( ) = "data2";			//( 불가능 )
		parent.method3( );					//( 불가능 )
		*/
		
		Child child = (Child) parent;		//강제 타입 변환
		child.field2 = "yyy";				//( 가능 )
		child.method3( ); 					//( 가능 )
	}
}
```



#### 결과

```java
Parent-method1( );
Parent-method2( );
Child-method1( )
```



### 객체 타입 확인( instanceof )

강제 타입 변환은 자식 타입이 부모 타입으로 변환되어 있는 상태에서만 가능하기 때문에 다음과 같이 부모 타입의 변수가 부모 객체를 참조할 경우 자식 타입으로 변환할 수 없다.

```java
Parent parent = new Parent( );
Child child = (Child) parent;			//강제 타입 변환 X
```

그렇다면 부모 변수가 참조하는 객체가 부모 객체인지 자식 객체인지 확인하는 방법은 없을까? 어떤 객체가 어떤 클래스의 인스턴스인지 확인하려면 instanceof 연산자를 사용할 수 있다.

instanceof 연산자의 좌항은 객체가 오고, 우항은 타입이 오는데, 좌항의 객체가 우항의 인스턴스이면 즉 우항의 타입으로 객체가 생성되었다면 true 그렇지 않으면 false를 산출한다.

```java
boolean result = 좌항(객체) instanceof 우항(타입)
```

instanceof 연산자는 매개값의 타입을 조사할 때 주로 사용된다. 메소드 내에서 강제 타입 변환이 필요할 경우 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인하고 안전하게 강제 타입 변환을 해야 한다.



```java
public void method(Parent parent) {
	if(parent instanceof Child) {		//Parent 매개 변수가 참조하는 객체가 Child인지 조사
		Child child = (Child) parent;
	}
}
```

만약 타입을 확인하지 않고 강제 타입 변환을 시도한다면 ClassCastException 예외가 발생할 수 있다. 다음 예제를 보자. InstanceofExample 클래스에서 method1( )과 method2( )는 모두 Parent 타입의 매개값을 받도록 선언했다.



#### 예제 Parent.java ( 부모 클래스 )

```java
public class Parent {
}
```



#### 예제 Child.java ( 자식 클래스 )

```java
public class Child extends Parent {
}
```



#### 예제 InstanceofExample.java ( 객체 타입 확인 )

````java
public class InstanceofExample {
    public static void method1(Parent parent){
        if(parent instanceof Child) {            //Child 타입으로 변환이 가능한지 확인
            Child child = (Child) parent;
            System.out.println("method1 - Child로 변환 성공");
        } else {
            System.out.println("method1 - Child로 변환 실패");
        }
    }

    public static void method2(Parent parent){
        Child child = (Child) parent;           //ClassCastException이 발생할 가능성 있음.
        System.out.println("method2 - Child로 변환 성공");
    }

    public static void main(String[] args) {
        Parent parentA = new Child();
        method1(parentA);                       //Child 객체를 매개값으로 전달
        method2(parentA);                       //Child 객체를 매개값으로 전달

        Parent parentB = new Parent();
        method1(parentB);                       //Parent 객체를 매개값으로 전달
        method2(parentB);                       //Parent 객체를 매개값으로 전달, 예외 발생
    }
}
````



#### 결과

```java
method1 - Child로 변환 성공
method2 - Child로 변환 성공
method1 - Child로 변환 실패
Exception in thread "main" java.lang.ClassCastException: class Parent cannot be cast to class Child (Parent and Child are in unnamed module of loader 'app')
        at InstanceofExample.method2(InstanceofExample.java:12)
        at InstanceofExample.main(InstanceofExample.java:23)
```



InstanceofExample 클래스에서 method1( )과 method2( )를 호출할 경우, Child 객체를 매개값으로 전달하면 두 메소드 모두 예외가 발생하지 않지만, Parent 객체를 매개값으로 전달하면 method2( )에서는 ClassCastException이 발생한다. method1( )은 instanceof 연산자로 변환이 가능한지 확인한 후 변환을 하지만, method2( )는 무조건 변환하려고 했기 때문이다. 예외가 발생하면 프로그램은 즉시 종료되기 때문에 method1( )과 같이 강제 타입 변환을 하기 전에 instanceof 연산자로 변환시킬 타입의 객체인지 조사해서 잘못된 매개값으로 인해 프로그램이 종료되는것을 막아야 한다.



## 8. 추상 클래스

### 추상 클래스의 개념

사전적 의미로 추상(abstract)은 실체 간에 공통되는 특성을 추출한 것을 말한다. 예를 들어 새, 곤충, 물고기 등의 실체에서 공통되는 특성을 추출해보면 동물이라는 공통점이 있다. 또 다른 예로 삼성, 현대, LG 등의 실체에서 공통되는 특성을 추출해보면 회사라는 공통점이 있다. 이와 같이 동물, 회사와 같이 구체적인 실체라기보다는 실체들의 공통되는 특성을 가지고 있는 추상적인 것이라고 볼 수 있다. 클래스에도 추상 클래스가 존재한다. 객체를 직접 생성할 수 있는 클래스를 실체 클래스라고 한다면 이 클래스들의 공통적인 특성을 추출해서 선언한 클래스를 추상 클래스라고 한다.충상 클래스와 실체 클래스는 상속의 관계를 가지고 있다. 추상 클래스가 부모이고 실체 클래스가 자식으로 구현되어 실체 클래스는 추상 클래스의 모든 특성을 물려받고, 추가적인 특성을 가질 수 있다. 여기서 특성이란 필드와 메소드들을 말한다. 예를 들어 Bird.class, Insect.class, Fish.class 등의 실체 클래스에서 공통되는 필드와 메소드를 따로 선언한  Animal.class 클래스를 만들 수 있는데, 이것이 추상 클래스이다.

![image-20210105234711916](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20210105234711916.png)

추상 클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 객체를 직접 생성해서 사용할 수 없다. 다시 말해서 추상 클래스는 new 연산자를 사용해서 인스턴스를 생성시키지 못한다.

```java
Animal aniaml = new Animal( );			//( X )
```

 추상 클래스는 새로운 실체 클래스를 만들기 위해 부모 클래스로만 사용된다. 코드로 설명하면 추상클래스는 extends 뒤에만 올 수 있는 클래스이다. 예를 들어 Ant 클래스를 만들기 위한 Animal 클래스는 다음과 같이 사용할 수 있다.

```java
class Ant extends Animal { ㆍㆍㆍ }		//( O )
```



### 추상 클래스의 용도

실체 클래스들의 공통적인 특성(필드, 메소드)을 뽑아내어 추상 클래스로 만드는 이유가 무엇일까?

##### 첫 번째, 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적

실체 클랫스를 설계하는 사람이 여러 사람일 경우, 실체 클래스마다 필드와 메소드가 제각기 다른 이름을 가질 수 있다.  예를 들어 소유자의 이름을 저장하는 필드를 Telephone에서는 owner라고 하고, smartPhone에서는 user라고 할 수 있다. 그리고 전원을 켜다라는 메소드를 Telephone에서는 turnOn( )으로 설계하고, SmartPhone에서는 powerOn( )이라고 설계할 수 있다. 동일한 데이터와 기능임에도 불구하고 이름이 다르다 보니, 객체마다 사용 방법이 달라진다. 이것보다는 Phone이라는 추상 클래스에 소유자인 owner 필드와 turnOn( ) 메소드를 선언하고 Telephone과 SmartPhone은 Phone을 상속함으로써 필드와 메소드 이름을 통일시킬 수 있다.

##### 두 번째, 실체 클래스를 작성할 때 시간을 절약

공통적인 필드와 메소드는 추상 클래스인 Phone에 모두 선언해 두고, 실체 클래스마다 다른 점만 실체 클래스에 선언하게 되면 실체 클래스를 작성하는데 시간을 절약할 수 있다. 아래 그림에서 보면 Telephone과 SmartPhone은 Phone을 상속받기 때문에 owner 필드와 turnOn( ) 메소드를 선언할 필요가 없다.

![image-20210106003913597](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20210106003913597.png)

개발 프로젝트에서 설계자와 코더는 일반적으로 다른 사람이다. 설계자는 코더에게 클래스는 어떤 구조로 작성해야 한다는 것을 알려줄 필요성이 있다. 단순히 문서로 코더에게 전달한다면, 코더가 실수로 필드와 메소드 이름을 다르게 코딩할 수 있다. 코더가 작성해야 할 클래스가 다수이고, 이 클래스들이 동일한 필드와 메소드를 가져야 할 경우, 설계자는 이 내용들을 추려내어 추상 클래스로 설계 규칙을 만드는 것이 좋다. 그리고 코더에게 추상 클래스를 상속해서 구체적인 클래스를 만들도록 지시하면 된다.

예를 들어 자동차를 설계할 때에는 일반적인 타이어 규격에 맞추어서 작성해야 한다. 특정한 타이어만 사용할 수 있도록 자동차를 설계하지는 않는다. 일반적인 타이어 규격에 준사하는 어떠한 타이어든 부착할 수 있도록 하기 위해서이다. 여기서 타이어 규격은 타이어 추상 클래스라고 불 수 있고, 타이어 규격에 준수하는 한국 타이어나 금호 타이어는 추상 클래스를 상속하는 실체 타이어 클래스라고 볼 수 있다. 

![image-20210106210253125](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20210106210253125.png)

### 추상 클래스 선언

추상 클래스를 선언할 때에는 클래스 선언에 abstract 키워드를 붙여야 한다. abstract를 붙이게 되면 new 연산자를 이용해서 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.

```java
public abstract class 클래스 {
	//필드
	//생성자
	//메소드
}
```

추상 클래스도 일반 클래스와 마찬가지로 필드, 생성자, 메소드를 선언을 할 수 있다. new 연산자로 직접 생성자를 호출할 수는 없지만 자식 객체가 생성될 때 super(ㆍㆍㆍ)를 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 반드시 있어야 한다. 다음은 Phone 클래스를 추상 클래스로 선언한 것이다.



#### 예제 Phone.java ( 추상 클래스 )

```java
public class Phone {
    //필드
    public String owner;

    //생성자
    public Phone(String owner) {
        this.owner = owner;
    }

    //메소드
    public void turnOn( ){
        System.out.println("폰 전원을 켭니다.");
    }

    public void turnOff( ) {
        System.out.println("폰 전원을 끕니다.");
    }
}
```



 #### 예제 SmartPhone.java ( 실체 클래스 )

```java
public class SmartPhone extends Phone {
    //생성자
    public SmartPhone(String owner) {
        super(owner);
    }

    //메소드
    public void internetSearch( ){
        System.out.println("인터넷 검색을 합니다.");
    }
}
```

다음은 Phone 추상 클래스를 상속해서 SmartPhone 자식 클래스를 정의한 것이다. SmartPhone 클래스의 생성자를 보면 super( owner ); 코드로 Phone의 생성자를 호출하고 있다.



#### 예제 PhoneExample ( 추상 클래스 )

```java
public class PhoneExample {
    public static void main(String[] args) {
        //Phone phone = new Phone( );

        SmartPhone smartPhone = new SmartPhone("홍길동");

        smartPhone.turnOn();            //Phone의 메소드
        smartPhone.internetSearch();
        smartPhone.turnOff();           //Phone의 메소드
    }
}
```

다음은 PhoneExample 클래스는 Phone의 생성자를 호출해서 객체를 생성할 수 없음을 보여준다. 대신 자식 클래스인 SmartPhone으로 객체를 생성해서 Phone의 메소드인 turnOn( ), turnOff( ) 메소드를 사용할 수 있음을 보여준다.



#### 결과

```java
폰 전원을 켭니다.
인터넷 검색을 합니다.
폰 전원을 끕니다.
```



### 추상 메소드와 오버라이딩

추상 클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은 추상적인 클래스이므로 실체 클래스의 멤버( 필드, 메소드 )를 통일화하는데 목적이 있다. 모든 실체들이 가지고 있는 메소드의 실행 내용이 동일하다면 추상 클래스에 메소드를 작성하는 것이 좋을 것이다. 하지만 메소드의 선언만 통일화 하고, 실행 내용은 실체 클래스마다 달라야 하는 경우가 있다. 예를 들어 모든 동물은 소리를 내기 때문에 Animal 추상 클래스에서 sound( ) 라는 메소드를 정의했다고 하자. 그렇다면 어떤 소리를 내도록 해야 하는데, 이것은 실체에서 직접 작성해야 될 부분임을 알게 된다. 왜냐하면 동물은 다양한 소리를 내기 때문에 이것을 추상 클래스에서 통일적으로 작성할 수 없기 때문이다. 그렇다고 해서 sound( ) 메소드를 실체에서 작성하도록 하면 sound( ) 메소드를 잊어버리고 작성하지 않을 수도 있기 때문에 동물은 소리를 낸다는 것에 위배된다. 

이런 경우를 위해서 추상 클래스는 추상 메소드를 선언할 수 있다. 추상 메소드는 추상 클래스에서만 선언할 수 있는데, 메소드의 선언부만 있고 메소드 실행 내용인 중괄호 { }가 없는 메소드를 말한다. 추상 클래스를 설계할 때, 하위 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메소드가 있을 경우, 해당 메소드를 추상 메소드로 선언하면 된다. 자식 클래스는 반드시 추상 메소드를 재정의(오버라이딩)해서 실행 내용을 작성해야 하는데, 그렇지 않으면 컴파일 에러가 발생한다. 이것이 추상 메소드의 위력 이다. 다음은 추상 메소드를 선언하는 방법을 보여준다.

```java
[ public | protected ] abstract 리턴타입 메소드명(매개변수, ㆍㆍㆍ);
```

일반 메소드 선언과의 차이점은 abstract 키워드가 붙어 있고 메소드 중괄호 { } 가 없다. 다음은 Animal 클래스를 추상 클래스로 선언하고 sound( ) 메소드를 추상 메소드로 선언한 것이다.

```java
public abstract class Animal {
	public abstract void sound( );
}
```

어떤 소리를 내는지는 결정할 수 없지만 동물은 소리를 낸다는 공통적인 특징이 있으므로 sound( ) 메소드를 추상 메소드로 선언했다. Animal 클래스를 상속하는 하위 클래스는 고유한 소리를 내도록 sound( ) 메소드를 재정의해야 한다. 예를 들어 Dog는 "멍멍", Cat은 "야옹" 소리를 내도록 Dog, Cat 클래스에서 sound( ) 메소드를 재정의해야 한다.

![image-20210106214502009](C:\Users\samsung\AppData\Roaming\Typora\typora-user-images\image-20210106214502009.png)

다음은 Animal 클래스를 추상 클래스로 선언하고 sound( ) 메소드를 추상 메소드로 선언했다.



#### Animal.java ( 추상 메소드 선언 )

```java
public abstract class Animal {      //추상 클래스
    public String kind;

    public void breathe( ) {
        System.out.println("숨을 쉽니다.");
    }

    public abstract void sound( );  //추상 메소드
}
```



#### Dog.java ( 추상 메소드 오버라이딩 )

```java
public class Dog extends Animal {
    public Dog( ) {
        this.kind = "포유류";
    }

    @Override
    public void sound( ) {
        System.out.println("멍멍");
    }
}
```



#### Cat.java ( 추상 메소드 오버라이딩 )

```java
public class Cat extends Animal {
    public Cat( ) {
        this.kind = "포유류";
    }

    @Override
    public void sound( ) {
        System.out.println("야옹");
    }
}
```



#### AniamlExample.java ( 실행 클래스 )

```java
public class AnimalExample {
    public static void main(String[] args) {
        Dog dog = new Dog( );
        Cat cat = new Cat( );
        dog.sound();
        cat.sound();
        System.out.println("-----");

        //변수의 자동 타입 변환
        Animal animal = null;
        animal = new Dog( );            //자동 타입 변환
        animal.sound();                 //재정의된 메소드 호출

        animal = new Cat( );            //자동 타입 변환
        animal.sound();                 //재정의된 메소드 호출
        System.out.println("-----");

        //메소드의 다형성
        animalSound(new Dog());         //자동 타입 변환
        animalSound(new Cat());         //자동 타입 변환
    }
        public static void animalSound(Animal animal) {
            animal.sound( );            //재정의된 메소드 호출
        }
}
```



#### 결과

```java
멍멍
야옹
-----
멍멍
야옹
-----
멍멍
야옹
```

